[{"title":"GUN/Linux编程|学习笔记","date":"2017-04-27T04:46:30.000Z","path":"2017/04/27/GUN-Linux编程[学习笔记]/","text":"本文为《GUN/Linux编程》的个人读书笔记 &lt;未完待续&gt; 目录： 历史 Shell命令 Linux系统的定制 Shell程序设计 GUN C开发环境 Linux文件与目录 Linux信号 Linux进程 Linux进程通信 I/O操作模式 正文： ##历史&lt;未完待续&gt; ##Shell命令2.1.1 目录的组织结构系统目录树： [root@VM_9_128_centos //]# tree -L 1 . |-- bin -&gt; usr/bin #所有用户可使用的可执行文件 |-- boot #Linux内核映像文件和与引导加载有关的文件 |-- data |-- dev #所有设备文件，包括字符设备和块设备 |-- etc #系统配置文件 |-- home |-- lib -&gt; usr/lib #共享库文件，供/bin下的文件和/sbin下的文件使用 |-- lib64 -&gt; usr/lib64 |-- lost+found |-- media |-- mnt #挂载点，常用于挂载文件系统 |-- opt |-- proc #基于内存的文件系统，用于显示内核消息 |-- project |-- root |-- run |-- sbin -&gt; usr/sbin |-- srv |-- sys |-- tmp |-- usr |-- /usr/bin #用户命令文件 |-- /usr/include #C头文件 |-- /usr/lib #函数库 |-- /usr/src #源代码目录 |-- /usr/sbin #系统命令工具 |-- var `-- zxLiao “/“表示根目录。为了便于管理，每个目录中存放两个特殊目录，分别表示当前目录”.”和父目录”..” 2.1.2 文件的路径当”/“位于字符串首位时，表示根目录，位于两个目录之间时，表示分隔符。1.用户主目录：每个用户在登录进系统时，都位于某个目录，该目录称为用户主目录。root用户的用户主目录是/root,普通用户的用户主目录通常都是/home/username。2.绝对路径：从根目录开始到目标目录3.相对路径：从当前目录到目标目录 2.1.3 Linux的语法结构命令常用的语法结构定义如下： $ 命令名 [选项] [参数列表] 其中，$为提示符，提示符可以通过环境变量重新设置，命令名代表命令的名称，","excerpt":"本文为《GUN/Linux编程》的个人读书笔记","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Flask-Web开发|学习笔记","date":"2017-04-27T03:02:03.000Z","path":"2017/04/27/Flask-Web开发[学习笔记]/","text":"本文是《Flask-Web开发:基于Python的Web应用开发实战》的个人学习笔记 目录： 安装 使用虚拟环境 使用pip安装Python包 程序的基本结构 初始化 路由和视图函数 启动服务器 一个完整的循环 请求 - 响应循环 程序和请求上下文 请求调度 请求钩子 响应 Flask扩展 模板 JinJa2 模板引擎 渲染模板 变量 控制结构 使用Flask-Bootstrap 集成 Twitter Bootstrap 自定义错误页面 链接 静态文件 使用Flask-Monment本地化日期和时间 Web表单 跨站请求伪造保护 表单类 把表单渲染成HTML 在视图函数中处理表单 重定向和用户会话 Flash消息 数据库 电子邮件 大型程序的结构 项目结构 配置选项 程序包 使用程序工厂函数 在蓝本中实现程序功能 启动脚本 需求文件 单元测试 创建数据库 用户认证 Flask的认证扩展 密码安全性 创建认证蓝本 使用Flask-Login认证用户 准备用于登录的用户模型 保护路由 添加登录表单 登入用户 登出用户 测试登录 注册新用户 添加用户注册表单 注册新用户 确认账户 使用isdangerous生成确认令牌 发送确认邮件 管理账户 用户角色 角色在数据库中的表示 赋予角色 角色验证 用户资料 资料信息 用户资料页面 资料编辑器 用户级别的资料编辑器 管理员级别的资料编辑器 用户头像 博客文章 关注者 用户评论 应用编程接口 测试 性能 部署 其他 #1安装 ##1.1 使用虚拟环境虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python解释器。虚拟环境非常有用，可以在系统的Python解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。使用虚拟环境还有个好处，那就是不需要管理员权限。虚拟环境使用第三方实用工具 virtualenv 创建。输入以下命令可以检查系统是否安装了 virtualenv： $ virtualenv --version 当你有多个项目的时候，有可能会遇到不同项目所依赖的包的版本不一致的情况，糟糕的是可能会有某些关键的外部库前后两个版本并不兼容，这个时候virtualenv就很有用处，可以为每个项目创建一个虚拟环境，这样各个项目之间就不会冲突 如果结果显示错误，你就需要安装这个工具。使用以下命令安装： $ sudo yum install virtualenv 下一步是使用 virtualenv 命令在 flasky 文件夹中创建 Python 虚拟环境。这个命令只有一 个必需的参数，即虚拟环境的名字。创建虚拟环境后，当前文件夹中会出现一个子文件 夹，名字就是上述命令中指定的参数，与虚拟环境相关的文件都保存在这个子文件夹中。 按照惯例，一般虚拟环境会被命名为 venv： $ virtualenv venv New python executable in venv/bin/python2.7 Also creating executable in venv/bin/python Installing setuptools............done. Installing pip...............done. 现在，flasky文件夹中就有了一个名为venv的子文件夹，它保存一个全新的虚拟环境，其 中有一个私有的 Python 解释器。在使用这个虚拟环境之前，你需要先将其“激活”。如果 你使用 bash 命令行（Linux 和 Mac OS X 用户），可以通过下面的命令激活这个虚拟环境： $ source venv/bin/activate 虚拟环境被激活后，其中 Python 解释器的路径就被添加进 PATH 中，但这种改变不是永久 性的，它只会影响当前的命令行会话。为了提醒你已经激活了虚拟环境，激活虚拟环境的 命令会修改命令行提示符，加入环境名： (venv) $ 当虚拟环境中的工作完成后，如果你想回到全局 Python 解释器中，可以在命令行提示符下 输入 deactivate ##1.2 使用pip安装Python包大多数 Python 包都使用 pip 实用工具安装，使用 virtualenv 创建虚拟环境时会自动安装 pip。激活虚拟环境后，pip 所在的路径会被添加进 PATH。 执行下述命令可在虚拟环境中安装 Flask： (venv) $ pip install flask 执行上述命令，你就在虚拟环境中安装 Flask 及其依赖了。要想验证 Flask 是否正确安装， 你可以启动 Python 解释器，尝试导入 Flask： (venv) $ python &gt;&gt;&gt; import flask &gt;&gt;&gt; 如果没有看到错误提醒，就说明Flask安装完毕。 #2 程序的基本结构 ##2.1 初始化 所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口 （Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这 个对象处理。程序实例是 Flask 类的对象，经常使用下述代码创建： from flask import Flask app = Flask(__name__) Flask 类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序 中，Python 的 ‘name‘ 变量就是所需的值。 ##2.2 路由和视图函数客户端（例如 Web 浏览器）把请求发送给 Web 服务器，Web 服务器再把请求发送给 Flask程序实例。程序实例需要知道对每个 URL 请求运行哪些代码，所以保存了一个 URL 到 Python 函数的映射关系。处理URL和函数之间关系的程序称为路由。 路由可以理解为请求的URL 在 Flask 程序中定义路由的最简便方式，是使用程序实例提供的 app.route 修饰器，把修 饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由： @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; 上例把 index() 函数注册为程序根地址的处理程序。如果部署程序的服务器域名为 www. example.com，在浏览器中访问 http://www.example.com 后，会触发服务器执行 index() 函 数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是 Web 浏览器，响 应就是显示给用户查看的文档。像index()这样的函数称为视图函数（view function）。视图函数返回的响应可以是包含 HTML 的简单字符串，也可以是复杂的表单。 如果你仔细观察日常所用服务的某些 URL 格式，会发现很多地址中都包含可变部分。例 如， 你 的 Facebook 资 料 页 面 的 地 址 是 http://www.facebook.com/， 用 户 名 （your-name）是地址的一部分。Flask 支持这种形式的 URL，只需在 route 修饰器中使用特 殊的句法即可。下例定义的路由中就有一部分是动态名字： @app.route(&apos;/user/&lt;name&gt;&apos;) def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name 尖括号中的内容就是动态部分，任何能匹配静态部分的 URL 都会映射到这个路由上。调 用视图函数时，Flask 会将动态部分作为参数传入函数。在这个视图函数中，参数用于生 成针对个人的欢迎消息。 路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由 /user/ 只会匹配动态片段 id 为整数的 URL。Flask 支持在路由中使用 int、float 和 path 类型。 path 类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。 ##2.3 启动服务器程序实例用 run 方法启动 Flask 集成的开发 Web 服务器： if __name__ == &apos;__main__&apos;: app.run(debug=True) debug模式打开的情况下如果程序出错可以在浏览器中看到报错信息 __name__==&#39;__main__&#39;是 Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发 Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因 此不会执行 app.run()。服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按 Ctrl-C 键。有一些选项参数可被 app.run() 函数接受用于设置 Web 服务器的操作模式。在开发过程中 启用调试模式会带来一些便利，比如说激活调试器和重载程序。要想启用调试模式，我们 可以把 debug 参数设为 True。 ##2.4 一个完整的程序前几节介绍了 Flask Web 程序的不同组成部分，现在是时候开发一个程序了。整个 hello.py 程序脚本就是把前面介绍的三部分合并到一个文件中。程序代码如示例 2-1 所示。一个完整的 Flask 程序: from flask import Flask app = Flask(__name__) @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; if __name__ == &apos;__main__&apos;: app.run(debug=True) 打开 Web 浏览器，在地址栏中输入 http://127.0.0.1:5000/ 即可看到返回的 Hello World! from flask import Flask app = Flask(__name__) @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; @app.route(&apos;/user/&lt;name&gt;&apos;) #动态路由 def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name if __name__ == &apos;__main__&apos;: app.run(debug=True) 访问 http://localhost:5000/user/Dave。 程序会显示一个使用 name 动态参数生成的欢迎消息。尝试使用不同的名字，可以看到视 图函数总是使用指定的名字生成响应.","excerpt":"本文是《Flask-Web开发:基于Python的Web应用开发实战》的个人学习笔记","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Flask-Web开发","slug":"Flask-Web开发","permalink":"http://yoursite.com/tags/Flask-Web开发/"}]},{"title":"hexo+Github搭建个人博客","date":"2017-04-02T07:33:53.000Z","path":"2017/04/02/hexo-Github搭建个人博客/","text":"&lt;未完待续&gt; 这篇博文记录一下利用gtihub 的github page的hexo搭建个人博客的方法顺便作为一个教程。 如果你说你不会html，不会DIV+CSS，不会JavaScript，不知道Bootstrap，也不想维护数据库，不知道怎么搭网页的服务器，甚至都不想去租服务器来搭载你的个人博客，那也没关系，那么这个教程很适合你。这篇教程保证你可以在不用写一行代码就可搭建出一个漂亮的个人博客。 这篇教程会从零开始，何为从零开始，就是假设你没有github账号，没有配置git，不会用markdown写文档。在这篇教程的引导下你依然可以畅通无阻！ 那么，开始吧~ 目录： Node.js 下载 安装 检查 Github Github介绍 注册 添加仓库 添加ssh Git Bash Git介绍 下载 安装 配置 markdown markdown介绍 下载 安装 markdown简单语法 sublime sublime介绍 sublime下载 sublime安装 hexo hexo介绍 hexo下载 hexo配置文件介绍 hexo操作示例 ##Node.js ###1.进入官网，选择对应版本下载点此处打开node.js官网 → Node.js官网 进入官网之后点击DOWNLOADS页面选择相应的版本下载即可： .msi文件有安装引导程序，会更方便一些 ###2.安装下载完成后双击运行下载完成的.msi文件，弹出安装引导程序：2.1安装引导程序-Next 2.2许可协议界面-同意之后Next 2.3选择安装路径-Next 这里你可以更改node.js的存储路径 2.4自定义安装-Next 2.5准备就绪-Install 2.6安装中-等待安装完毕 2.7安装完成-Finish ###3.检查是否正确配置Home + R 然后 cmd 呼出控制台, 执行： node -v 如果返回node的版本就说明node已经加到系统的PATH中，可以在任何地方运行node相关命令 如果提示 &apos;node&apos; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 需要把你刚才安装node的路径添加到系统path变量中。 ##Github ###Github介绍GitHub 是一个面向开源及私有软件项目的托管平台，可以实现软件的版本控制你也可以把它当做你的代码的云备份 ###注册Github账号点击此处跳转到Github注册界面 → Github注册 ### 2.验证邮箱 √3.添加ssh验证 √ ##安装markdown1.下载 √2.安装 √3.破解 √4.基本语法 √ ##安装Git Bash1.下载 √2.安装 √ 现在你需要创建一个文件夹，以后专门给github用 github是一个代码托管网站 也就是说你写的代码可以放到这里，当做云备份待会的博客代码是需要放到github上的所以才配置了github 现在需要在github上创建一个项目(github把项目称做仓库) 这个博客的话，因为一些原因，名字必须叫做 “用户名.github.io” github上这个叫做远程库 你本地这个叫做本地仓库 现在这两个仓库还没有建立连接 首先，需要把本地仓库初始化成git可以管理的文件夹 现在需要安装hexo(就是博客的模板)","excerpt":"","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/tags/环境配置/"}]},{"title":"HTTP协议","date":"2017-03-30T06:28:53.000Z","path":"2017/03/30/HTTP协议/","text":"http请求头目录： 请求方法 状态码 通用 通用头域 请求头(Requests Headers) 响应头(Response) ##请求方法 请求方法有以下这些，常用的是GET,POST GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 ##状态码 所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 &gt;的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 常见状态代码、状态描述、说明： 200 OK //请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ##通用 Request URL:https://zhuanlan.zhihu.com/p/25296437请求网址：这个对应HTTP协议中的统一资源定位符也就是我们打开的网址 Request Method:GET请求方法：这个对应HTTP协议中的请求方法 Status Code:200 OK状态码：这个对应HTTP协议中的状态码 ##通用头域通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。 实体 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。 Cache-Control头域 Cache- Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Connection:keep-alive HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。 Content-Encoding Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。 Content-Type 用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 如果未指定 ContentType，默认为TEXT/HTML。 用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头 Date头域 Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 Expires（过期时间）HTTP头信息 Expires（过期时间） 属性是HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修 改。 Expires 头信息：对于设置静态图片文件（例如导航栏和图片按钮）可缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对 用户变得相应非常快；他们对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存 服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的“刷新”按钮。 Pragma头域 Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。 Host头域 Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。 Referer头域 Referer 头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。 Range头域 Range头域可以请求实体的一个或者多个子范围。例如， 表示头500个字节：bytes=0-499 表示第二个500字节：bytes=500-999 表示最后500个字节：bytes=-500 表示500字节以后的范围：bytes=500- 第一个和最后一个字节：bytes=0-0,-1 同时指定几个范围：bytes=500-600,601-999 但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）。 ##请求头(Requests Headers) Host头域 Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。 当前请求网址的请求域 User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 用户是通过什么工具来请求的 User-Agent头域的内容包含发出请求的用户信息。 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。 Accept-Language:zh-CN,zh;q=0.8 Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受 Accept-Encoding:gzip, deflate, sdch, br Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 Content-Type 用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 如果未指定 ContentType，默认为TEXT/HTML。 在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 例如： Content-Type: text/html;charset:utf-8; 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。 Content-Encoding Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。 内容编码目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过 gzip 压缩过的文本响应，只有原始大小的 1/4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于 JPG / PNG 这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费 CPU。 Referer:https://www.zhihu.com/people/pa-chong-21/activities 是通过哪个页面到当前页面的（也就是上一个页面是什么？） 举个例子，当我是通过百度搜索页面点到当前页面的，那么Referer就是百度搜索页 Content-Length 用于描述HTTP消息实体的传输长度。 消息实体长度：即Entity-length，压缩之前的message-body的长度 消息实体的传输长度：Content-length，压缩后的message-body的长度。 Origin origin主要是用来说明最初请求是从哪里发起的； origin只用于Post请求，而Referer则用于所有类型的请求； origin的方式比Referer更安全点吧。 Cookie:d_c0=&quot;AACAWNtZswqPTnJ8dFXqaygiq82ekPD5_-xxxx 举个例子，当我登录知乎后，知乎会给我一个cookie，然后我在以后的一段时间内，每次打开知乎，都不需要重新登录。这是因为浏览器每次都会把我之前存储的cookie带上。 Connection:keep-alive HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。 Upgrade Insecure Requests 我们的页面是 https 的，而这个页面中包含了大量的 http 资源（图片、iframe等），页面一旦发现存在上述响应头，会在加载 http 资源时自动替换成 https 请求。 Cache-Control:no-cache Cache-Control 是用来控制网页的缓存 If-Modified-Since:Wed, 15 Feb 2017 09:14:13 GMT(缓存时间) If-None-Match:W/&quot;58a41be5-190aa&quot; Last-Modified:Wed, 15 Feb 2017 09:14:13 GMT ETag:&quot;58a41be5-190aa&quot; 这4个一般静态页面会用到 If-Modified-Since,If-None-Match这两个是请求头，ETag,Last-Modified是返回头（服务器返回的） 如果If-Modified-Since的值和Last-Modified相等 则表明当前请求的内容没有变动，服务器返回,If-None-Match和ETag 同理 ##响应头(Response) Public-Key- Pins Public-Key- Pins (PKP)的目的主要是允许网站经营者提供一个哈希过的公共密钥存储在用户的浏览器缓存里。跟Strict-Transport-Security功能相 似的是，它能保护用户免遭中间人攻击。这个header可能包含多层的哈希运算，比如pin-sha256=base64(sha256(SPKI))， 具体是先将 X.509 证书下的Subject Public Key Info (SPKI) 做sha256哈希运算，然后再做base64编码。然而，这些规定有可能更改，例如有人指出，在引号中封装哈希是无效的，而且在33版本的chrome 中也不会保存pkp的哈希到缓存中。 这个header和 STS的作用很像，因为它规定了最大子域名的数量。此外，pkp还提供了一个Public-Key-Pins-Report-Only 头用来报告异常，但是不会强制阻塞证书信息。当然，这些chrome都是不支持的。 Server响应头 Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。 来自： http://blog.csdn.net/mm2223/article/details/8089645/http://fex.baidu.com/blog/2014/05/what-happen/ (计算机网络)http://blog.csdn.net/blueheart20/article/details/45174399 (请求头、响应头)http://www.tuicool.com/articles/b6BNNfN (Accept-Encoding 和 Content-Encoding)","excerpt":"http请求头目录： 请求方法 状态码 通用 通用头域 请求头(Requests Headers) 响应头(Response)","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"Python网络爬虫与信息提取","date":"2017-03-30T06:16:22.000Z","path":"2017/03/30/Python网络爬虫与信息提取/","text":"#Python网络爬虫与信息提取这个笔记是跟着北京理工大学计算机学院「嵩天副教授」在中国大学MOOC上的课程《Python网络爬虫与信息提取》所做的学习笔记 ##requests库的get()方法 r = requests.get()其中requests.get()是构造一个向服务器请求资源的Request对象其中r是一个包含服务器资源的Response对象 # -*- coding=UTF-8 -*- # 2017年2月28日17:40:30 import requests url = &apos;http://www.baidu.com&apos; r = requests.get(url) print type(r) #打印r的类型 print r.status_code #打印http请求返回的状态码 print r.headers #打印响应头 运行结果： &lt;class &apos;requests.models.Response&apos;&gt; 200 {&apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Set-Cookie&apos;: &apos;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&apos;, &apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Last-Modified&apos;: &apos;Mon, 23 Jan 2017 13:28:26 GMT&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 09:39:57 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;} Response对象的属性 属性 说明 r.status_code HTTP请求返回的状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式。即URL对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的相应内容编码方式(备选编码方式) r.content HTTP响应内容的二进制形式 一般认为r.apparent_encoding比r.encoding准确 # -*- coding=UTF-8 -*- # 2017-2-28 20:04:57 import requests url = &apos;http://www.baidu.com&apos; r = requests.get(url) print r.encoding #输出encoding的格式 r.encoding = r.apparent_encoding #转换r.text的编码格式 print r.text #输出返回的页面源码 运行结果： ISO-8859-1 &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&apos;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&apos;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &apos;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&apos;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ##爬取网页的通用代码框架Requests库的异常： 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requesrs.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status:如果不是返回状态码不是200，产生异常requests.HTTPError # -*- coding=UTF-8 -*- # 2017-2-28 21:01:51 import requests def GetHTMLText(url): try: r = requests.get(url) #发送HTTP请求 r.raise_for_status #抛出异常 r.encoding = r.apparent_encoding #改变编码方式 return r.text #返回网页内容 except: return &apos;代码异常&apos; if __name__ == &apos;__main__&apos;: url = &apos;http://www.baidu.com&apos; print GetHTMLText(url) ##HTTP协议及Requests库方法Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，是支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应与HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HEML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE HTTP协议简介URL格式：http://host[:port][path]host:合法的Internet主机域名或IP地址port:端口号，缺省端口为80path:请求资源的路径 HTTP URL的理解：URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源 HTTP协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 POST 请求向URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该出资源的部分内容 DELETE 请求删除URL位置存储的资源 requests库的head()方法 # -*- coding=UTF-8 -*- # 2017-2-28 21:39:41 import requests url = &apos;http://www.baidu.com&apos; r = requests.head(url) #requests库的head()方法 print r.headers #打印获取的头部信息 运行结果 {&apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Last-Modified&apos;: &apos;Mon, 13 Jun 2016 02:50:34 GMT&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 13:38:58 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;} requests库的post()方法 # -*- coding=UTF-8 -*- # 2017-2-28 21:44:35 import requests url = &apos;http://httpbin.org/post&apos; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} r = requests.post(url, data = payload) #requests库的post()方法 print r.text #打印文件内容 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } 新增了 &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, ##Requests库主要方法解析Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，是支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应与HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HEML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE requests.request(method, url, **kwars) method:请求方式，对应get/put/post等七种 r.requests.request(‘GET’, url, **kmargs) r.requests.request(‘HEAD’, url, **kmargs) r.requests.request(‘POST’, url, **kmargs) r.requests.request(‘PUT’, url, **kmargs) r.requests.request(‘PATCH’, url, **kmargs) r.requests.request(‘delete’, url, **kmargs) r.requests.request(‘OPTIONS’, url, **kmargs) url:拟获取页面的URL链接 **kwargs:控制访问的参数，共13个 params:字典或字节序列，作为参数增加到url中 # -*- coding=UTF-8 -*- # 2017-2-28 21:56:50 import requests url = &apos;http://httpbin.org/post&apos; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} r = requests.request(&apos;GET&apos;, url, params = payload) #request方法的params参数 print r.url #打印url 运行结果 http://httpbin.org/post?key2=value2&amp;key1=value1 data:字典、字节序列或文件对象，作为Requests的内容 # -*- coding=UTF-8 -*- # 2017-2-28 22:06:00 import requests url = &apos;http://httpbin.org/post&apos; kv = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key3&apos;: &apos;value3&apos;} r = requests.request(&apos;POST&apos;, url, data = kv) #request方法的data参数 print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;35&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } json：JSON格式的数据，作为Request的内容 # -*- coding=UTF-8 -*- # 2017-2-28 22:08:57 import requests url = &apos;http://httpbin.org/post&apos; kv = {&apos;key1&apos;: &apos;value1&apos;} r = requests.request(&apos;POST&apos;, url, json = kv) #request方法的json参数 print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;{\\&quot;key1\\&quot;: \\&quot;value1\\&quot;}&quot;, &quot;files&quot;: {}, &quot;form&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;18&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: { &quot;key1&quot;: &quot;value1&quot; }, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } header：字典，HTTP定制头 # -*- coding=UTF-8 -*- # 2017-2-28 22:13:23 import requests url = &apos;http://httpbin.org/post&apos; hd = {&apos;user-agent&apos;: &apos;Chrome/10&apos;} r = requests.request(&apos;POST&apos;, url, headers = hd) #request方法的header参数 print r.headers #输出对应资源 运行结果 {&apos;Content-Length&apos;: &apos;316&apos;, &apos;Server&apos;: &apos;nginx&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 14:11:55 GMT&apos;, &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;} cookies:字典或CookieJar,Request中的cookie auth:元组，支持HTTP认证功能 files:字典类型，传输文件 # -*- coding=UTF-8 -*- # 2017-2-28 22:51:51 import requests url = &apos;http://httpbin.org/post&apos; fs = {&apos;files&apos;: open(&apos;stdin.txt&apos;, &apos;rb&apos;)} r = requests.request(&apos;POST&apos;, url, files = fs) #request方法的files参数 r.encoding = r.apparent_encoding print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: { &quot;files&quot;: &quot;just some test\\r\\nanother&quot; }, &quot;form&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;169&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=76d625c06e9245209af4d8a44efd9210&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } timeout: 设定超时时间，秒为单位 r = requests.request(&apos;GET&apos;, url, timeout = 10) proxies:字典类型，设定访问代理服务器，可以增加登录认证 pxs = {&apos;http&apos;: &apos;http://user:pass@10.10.10.1:1234&apos;, &apos;https&apos;: &apos;https://10.10.10.1:4321&apos;} r = requests.request(&apos;GET&apos;, &apos;http://www.baidu.com&apos;, proxies=pxs) allow_redirects: True/False，默认为True，重定向开关 stream:True/False, 默认为True，获取内容立即下载开关 verify:True/False, 默认为True，认证SSL证书开关 cert:本地SSL证书路径 requests.get(url, params=None, **kwargs) url:拟获取页面的URL params:url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数(除了params) requests.head(url, **kwargs) url:拟获取页面的URL **kwargs：13个控制访问的参数 requests.post(url, data=None, json=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 json：JSON格式的数据，Request的内容 **kwargs：11个控制访问的参数 requests.put(url, data=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 **kwargs：12个控制访问的参数 requests.patch(url, data=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 **kwargs：12个控制访问的参数 requests.delete(url, **kwargs) url:拟获取页面的URL **kwargs：13个控制访问的参数 ##Robots协议作用：网站告知网络爬虫哪些页面可以抓取，哪些不行形式：在网站根目录下的robots.txt文件 ##Requests库的网络爬虫实战 ###实例1：京东商品页面的爬取 # -*- coding=UTF-8 -*- # 2017-3-1 10:33:03 import requests def getHTML(url): try: r = requests.get(url) #发送HTML请求 r.raise_for_status() #抛出异常 r.encoding = r.apparent_encoding #改变编码 return r.text[:1000] #返回前1000个字符 except: return &apos;程序异常&apos; if __name__ == &apos;__main__&apos;: #执行脚本 url = &apos;https://item.jd.com/2967929.html&apos; print getHTML(url) 运行结果 &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gbk&quot; /&gt; &lt;title&gt;【华为荣耀8】荣耀8 4GB+64GB 全网通4G手机 魅海蓝【行情 报价 价格 评测】-京东&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HUAWEI荣耀8,华为荣耀8,华为荣耀8报价,HUAWEI荣耀8报价&quot;/&gt; &lt;meta name=&quot;description&quot; content=&quot;【华为荣耀8】京东JD.COM提供华为荣耀8正品行货，全国价格最低，并包括HUAWEI荣耀8网购 指南，以及华为荣耀8图片、荣耀8参数、荣耀8评论、荣耀8心得、荣耀8技巧等信息，网购华为荣耀8上京东,放心又轻松&quot; /&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta http-equiv=&quot;mobile-agent&quot; content=&quot;format=xhtml; url=//item.m.jd.com/product/2967929.html&quot;&gt; &lt;meta http-equiv=&quot;mobile-agent&quot; content=&quot;format=html5; url=//item.m.jd.com/product/2967929.html&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;link rel=&quot;canonical&quot; href=&quot;//item.jd.com/2967929.html&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; hr ###实例2：亚马逊商品页面的爬取","excerpt":"#Python网络爬虫与信息提取这个笔记是跟着北京理工大学计算机学院「嵩天副教授」在中国大学MOOC上的课程《Python网络爬虫与信息提取》所做的学习笔记","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Spider","slug":"Spider","permalink":"http://yoursite.com/tags/Spider/"}]},{"title":"使用yilia主题遇到的一些问题","date":"2017-03-29T13:56:33.000Z","path":"2017/03/29/使用yilia主题遇到的一些问题/","text":"&lt;未完待续&gt; ###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式所以就去翻yilia的配置文件啦在blog根目录下执行： vim ./themes/yilia/_config.yml 打开yilia的配置文件经过一番(神TM)推断-.-觉得文章显示全文与否的关键地方应该是这里： # 文章太长，截断按钮文字 excerpt_link: more 虽然看不懂英文，但是看懂了“文章太长”这四个字，然而下面这一句没看懂…..查了一下：excerpt–摘录、引用。 确认是这个但是还是不明白是如何使用它。经过一番天真的猜测，难道是文中出现这个词就会截断，所以叫截断按钮文字？？但是万一文档中本来就要有这个词[more]那不就有二义性了吗=.=先不想那么多，有猜想就试试吧~打开markdown文档，在第一段之后加了more，然后提交更改：hexo g -d然而….并没有预期中的效果，好吧，不是原来想的这个求问度娘0.0 然而…找半天也没看到我这个问题的解决方法，屁颠屁颠跑去知乎提了这个问题，问题挂上去之后又翻了翻度娘，竟然意外翻到了，原来是要把more放在标签里。好吧….我好傻格式是：&lt;!-- more --&gt;在文中要截断的地方加上这个标签就可以在主页上实现预览的效果了，主页里显示到这个标签之前的内容，剩下的内容可以点击展开，效果如下： ###2.如何给文章添加多标签在文章的tag标签下以无序列表的形式列出，比如： --- title: 使用yilia主题遇到的一些问题 date: 2017-03-29 21:56:33 tags: - 笔记 - 技巧 --- 效果如下： 3.如何更改主页的头像到blog根目录下执行命令： vim ./themes/yilia/_config.yml 进入yilia主题的配置文件找到这个： #你的头像url avatar: 添加avatar的值，头像的url这个可以把头像存到github上，然后把github上给出的这个图像的url填上去就可以","excerpt":"&lt;未完待续&gt; ###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"密码学的数学基础","date":"2017-03-29T12:03:36.000Z","path":"2017/03/29/密码学的数学基础/","text":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模 欧几里得算法gcd() /*@function int gcd(int a, int b)@author ZXLiao@data 2017-3-2 10:28:22@param a integer@param b integer@return Greatest Common Divisor**/ int gcd(int a, int b){ if(b == 0){ return a; } return gcd(b, a % b);} 扩展欧几里得算法extent_gcd() /******************** @function int extend_gcd(int a, int b, int &amp;x, int &amp;y) @author ZXLiao @data 2017-3-2 17:55:32 @param a coefficient_a @param b coefficient_b @param x solution_x @param y solution_y @return gcd(a, b) x y ********************/ int extend_gcd(int a, int b, int &amp;x, int &amp;y){ /* 大前提保证： ①ax + by = gcd(a, b)一定有整数解。 ②bx + (a%b)y = gcd(b, a%b) 与①有相同解 如果b==0；那么方程就是ax=gcd(a, b) = a； 即x = 1；另取y = 0(也可以取其他值)； */ if(b == 0){ x = 1; y = 0; return a; } int gcd = expand_gcd(b, a%b, x, y); int t = x - a/b*y; // 表达式中有x，避免x改变； x = y; y = t; return gcd; //返回的是gcd(a, b); } 乘法逆元mod_inverse() /****************** @function int mod_inverse(int a, int m) @author ZXLiao @data 2017-3-2 18:59:30 @param a @param m mod @return if without the mod_inverse return -1 else return the inverse of a under modulo m ******************/ int mod_inverse(int a, int m){ if(gcd(a, m) != 1){ return -1; } int x, y; extend_gcd(a, m, x, y); return ((x % m + m) % m); } 素数筛法求素数is_Prime() /******************** @function bool is_Prime(int a) @author ZXLiao @data 2017-3-2 22:37:02 @param a integer @return if a is a Prime return true else return false ********************/ #define __MAX 10000 bool Prime[__MAX]; void get_Prime(){ memset(Prime, true, sizeof(Prime)); Prime[0] = false; for(int i = 1; i &lt;= __MAX; i++){ if(Prime[i]){ int item = 2 * i + 1; for(int j = item * item; j &lt;= __MAX; j += (2 * item)){ Prime[j &gt;&gt; 1] = false; } } } } bool is_Prime(int a){ if(a == 2) return true; if(a &amp; 1) return Prime[a &gt;&gt; 1]; else return false; } 快速幂取模quick_pow() /******************** @function int quick_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-2 22:53:17 @param a @param n @param __MOD modulo @return (a^n)%__MOD ********************/ int quick_pow(int a, int n, int __MOD){ if(n == 0) return 1; if(n &amp; 1) return a * quick_pow(a, n - 1, __MOD) % __MOD; int t = quick_pow(a, n &gt;&gt; 1, __MOD); return t * t % __MOD; } 欧拉函数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define N 1000005 #define M 78500 //预先算出1000000内的素数个数是78499 using namespace std; bool is_Prime[N]; //用于素数筛法 int Prime[M]; //存放素数 long long int oula[N]; //存放欧拉函数 int p; void Get_Prime(){ //首先筛法筛出1000000以内的素数 memset(is_Prime, 1, sizeof(is_Prime)); is_Prime[0] = is_Prime[1] = 0; for(long long int i = 2; i &lt; N; i++){ if(is_Prime[i]){ for(long long int j = i * i; j &lt; N; j += i){ is_Prime[j] = 0; } } } } void Init(){ p = 0; for(int i = 0; i &lt; N; i++){ if(is_Prime[i]){ Prime[p++] = i; oula[i] = i - 1; } } } int main () { Get_Prime(); //根据布尔数组的值，把素数存在数组内，并且对素数的欧拉函数进行赋值 Init(); /* 欧拉函数递推关系的推导： 对于oula[x]： oula[x] = x *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ① 此时，考虑oula[x/p1]的函数值 一：倘若x/p1此时还有一个素因子p1，那么： oula[x/p1] = x/p1 *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ② 对比①②两式可以得到oula[x] = oula[x/p1] * p1 二：倘若x/p1此时没有素因子p1，那么： oula[x/p1] = x/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ③ 对比①③两式可以得到oula[x] = oula[x/p1] * (p1 - 1) */ oula[0] = oula[1] = 1; //递推初始化 for(int i = 2; i &lt; N; i++){ if(!oula[i]){ //对合数进行欧拉函数求解 for(int j = 0; j &lt; p; j++){ //寻找一个素因子 if(i%Prime[j] == 0){ //找到一个素因子 int k = i/Prime[j]; //记录下i%Prime[j] if(k%Prime[j] == 0){ //对i%Prime[j]再次进行判断，发现可再次整除 oula[i] = oula[k] * Prime[j]; //递推关系 } else{ //递推关系 oula[i] = oula[k] * (Prime[j] - 1); } break; } } } } return 0; } 中国剩余定理 /******************* @function int chinese_remaining_theory(struct data _data[]) @author ZXLiao @data 2017-3-6 09:36:14 @param struct data _data: Congruence equations @return x *******************/ struct data{ int b; int m; }; int chinese_remaining_theory(struct data _data[]){ bool mark = 1; for(int i = 0; i &lt; N; i++){ for(int j = i + 1; j &lt; N; j++){ if(gcd(_data[i].m, _data[j].m) != 1){ mark = 0; break; } } } if(mark == 0){ return -1; } int M = 1; int Mi[N]; int inv[N]; int X = 0; for(int i = 0; i &lt; N; i++){ M *= _data[i].m; } for(int i = 0; i &lt; N; i++){ Mi[i] = M / _data[i].m; } for(int i = 0; i &lt; N; i++){ inv[i] = mod_inverse(Mi[i], _data[i].m); } for(int i = 0; i &lt; N; i++){ X += _data[i].b * inv[i] * Mi[i]; } return X % M; } 费马定理优化快速冥取模 /******************* @function int Format_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-6 09:48:44 @param a @param n @param __MOD modulo @return a^n % __MOD *******************/ int Format_pow(int a, int n, int __MOD){ if(gcd(a, __MOD) == 1){ return quick_pow(a, n % (__MOD - 1), __MOD); } return quick_pow(a, n, __MOD); }","excerpt":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://yoursite.com/tags/信息安全/"}]}]