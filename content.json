[{"title":"使用yilia主题遇到的一些问题","date":"2017-03-29T13:56:33.000Z","path":"2017/03/29/使用yilia主题遇到的一些问题/","text":"&lt;未完待续&gt; ###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式所以就去翻yilia的配置文件啦到blog目录下： 1234567891011121314151617181920212223242526272829303132333435363738394041vim ./themes/yilia/_config.yml``` 打开yilia的配置文件经过一番(神TM)推断-.- 觉得文章显示全文与否的关键地方应该是这里： # 文章太长，截断按钮文字 excerpt_link: more 虽然看不懂英文，但是看懂了“文章太长”这四个字，然而下面这一句没看懂..... 查了一下：excerpt--摘录、引用。 确认是这个 但是还是不明白是如何使用它。经过一番天真的猜测，难道是文中出现这个词就会截断，所以叫截断按钮文字？？但是万一文档中本来就要有这个词[more]那不就有二义性了吗=.= 先不想那么多，有猜想就试试吧~ 打开markdown文档，在第一段之后加了more，然后提交更改： `hexo g -d`然而....并没有预期中的效果，好吧，不是原来想的这个 求问度娘0.0 然而...找半天也没看到我这个问题的解决方法，屁颠屁颠跑去知乎提了这个问题，问题挂上去之后又翻了翻度娘，竟然意外翻到了，原来是要把more放在标签里。好吧....我好傻 格式是： `&lt;!-- more --&gt;` 在文中要截断的地方加上这个标签就可以在主页上实现预览的效果了，主页里显示到这个标签之前的内容，剩下的内容可以点击展开，效果如下： ![](https://raw.githubusercontent.com/CodeJxer/markdown_image/master/hexo/%E4%BD%BF%E7%94%A8yilia%E4%B8%BB%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/essaycut.png)###2.如何给文章添加多标签在文章的tag标签下以无序列表的形式列出，比如： --- title: 使用yilia主题遇到的一些问题 date: 2017-03-29 21:56:33 tags: - 笔记 - 技巧 ---效果如下： ![](https://raw.githubusercontent.com/CodeJxer/markdown_image/master/hexo/%E4%BD%BF%E7%94%A8yilia%E4%B8%BB%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/tags.png)3.如何更改主页的头像到blog目录下： vim ./themes/yilia/_config.yml``` 打开yilia的配置文件 找到这个： #你的头像url avatar: 添加avatar的值，头像的url这个可以把头像存到github上，然后把github上给出的这个图像的url填上去就可以","excerpt":"&lt;未完待续&gt; ###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"密码学的数学基础","date":"2017-03-29T12:03:36.000Z","path":"2017/03/29/密码学的数学基础/","text":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模 欧几里得算法gcd() /*@function int gcd(int a, int b)@author ZXLiao@data 2017-3-2 10:28:22@param a integer@param b integer@return Greatest Common Divisor**/ int gcd(int a, int b){ if(b == 0){ return a; } return gcd(b, a % b);} 扩展欧几里得算法extent_gcd() /******************** @function int extend_gcd(int a, int b, int &amp;x, int &amp;y) @author ZXLiao @data 2017-3-2 17:55:32 @param a coefficient_a @param b coefficient_b @param x solution_x @param y solution_y @return gcd(a, b) x y ********************/ int extend_gcd(int a, int b, int &amp;x, int &amp;y){ /* 大前提保证： ①ax + by = gcd(a, b)一定有整数解。 ②bx + (a%b)y = gcd(b, a%b) 与①有相同解 如果b==0；那么方程就是ax=gcd(a, b) = a； 即x = 1；另取y = 0(也可以取其他值)； */ if(b == 0){ x = 1; y = 0; return a; } int gcd = expand_gcd(b, a%b, x, y); int t = x - a/b*y; // 表达式中有x，避免x改变； x = y; y = t; return gcd; //返回的是gcd(a, b); } 乘法逆元mod_inverse() /****************** @function int mod_inverse(int a, int m) @author ZXLiao @data 2017-3-2 18:59:30 @param a @param m mod @return if without the mod_inverse return -1 else return the inverse of a under modulo m ******************/ int mod_inverse(int a, int m){ if(gcd(a, m) != 1){ return -1; } int x, y; extend_gcd(a, m, x, y); return ((x % m + m) % m); } 素数筛法求素数is_Prime() /******************** @function bool is_Prime(int a) @author ZXLiao @data 2017-3-2 22:37:02 @param a integer @return if a is a Prime return true else return false ********************/ #define __MAX 10000 bool Prime[__MAX]; void get_Prime(){ memset(Prime, true, sizeof(Prime)); Prime[0] = false; for(int i = 1; i &lt;= __MAX; i++){ if(Prime[i]){ int item = 2 * i + 1; for(int j = item * item; j &lt;= __MAX; j += (2 * item)){ Prime[j &gt;&gt; 1] = false; } } } } bool is_Prime(int a){ if(a == 2) return true; if(a &amp; 1) return Prime[a &gt;&gt; 1]; else return false; } 快速幂取模quick_pow() /******************** @function int quick_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-2 22:53:17 @param a @param n @param __MOD modulo @return (a^n)%__MOD ********************/ int quick_pow(int a, int n, int __MOD){ if(n == 0) return 1; if(n &amp; 1) return a * quick_pow(a, n - 1, __MOD) % __MOD; int t = quick_pow(a, n &gt;&gt; 1, __MOD); return t * t % __MOD; } 欧拉函数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define N 1000005 #define M 78500 //预先算出1000000内的素数个数是78499 using namespace std; bool is_Prime[N]; //用于素数筛法 int Prime[M]; //存放素数 long long int oula[N]; //存放欧拉函数 int p; void Get_Prime(){ //首先筛法筛出1000000以内的素数 memset(is_Prime, 1, sizeof(is_Prime)); is_Prime[0] = is_Prime[1] = 0; for(long long int i = 2; i &lt; N; i++){ if(is_Prime[i]){ for(long long int j = i * i; j &lt; N; j += i){ is_Prime[j] = 0; } } } } void Init(){ p = 0; for(int i = 0; i &lt; N; i++){ if(is_Prime[i]){ Prime[p++] = i; oula[i] = i - 1; } } } int main () { Get_Prime(); //根据布尔数组的值，把素数存在数组内，并且对素数的欧拉函数进行赋值 Init(); /* 欧拉函数递推关系的推导： 对于oula[x]： oula[x] = x *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ① 此时，考虑oula[x/p1]的函数值 一：倘若x/p1此时还有一个素因子p1，那么： oula[x/p1] = x/p1 *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ② 对比①②两式可以得到oula[x] = oula[x/p1] * p1 二：倘若x/p1此时没有素因子p1，那么： oula[x/p1] = x/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ③ 对比①③两式可以得到oula[x] = oula[x/p1] * (p1 - 1) */ oula[0] = oula[1] = 1; //递推初始化 for(int i = 2; i &lt; N; i++){ if(!oula[i]){ //对合数进行欧拉函数求解 for(int j = 0; j &lt; p; j++){ //寻找一个素因子 if(i%Prime[j] == 0){ //找到一个素因子 int k = i/Prime[j]; //记录下i%Prime[j] if(k%Prime[j] == 0){ //对i%Prime[j]再次进行判断，发现可再次整除 oula[i] = oula[k] * Prime[j]; //递推关系 } else{ //递推关系 oula[i] = oula[k] * (Prime[j] - 1); } break; } } } } return 0; } 中国剩余定理 /******************* @function int chinese_remaining_theory(struct data _data[]) @author ZXLiao @data 2017-3-6 09:36:14 @param struct data _data: Congruence equations @return x *******************/ struct data{ int b; int m; }; int chinese_remaining_theory(struct data _data[]){ bool mark = 1; for(int i = 0; i &lt; N; i++){ for(int j = i + 1; j &lt; N; j++){ if(gcd(_data[i].m, _data[j].m) != 1){ mark = 0; break; } } } if(mark == 0){ return -1; } int M = 1; int Mi[N]; int inv[N]; int X = 0; for(int i = 0; i &lt; N; i++){ M *= _data[i].m; } for(int i = 0; i &lt; N; i++){ Mi[i] = M / _data[i].m; } for(int i = 0; i &lt; N; i++){ inv[i] = mod_inverse(Mi[i], _data[i].m); } for(int i = 0; i &lt; N; i++){ X += _data[i].b * inv[i] * Mi[i]; } return X % M; } 费马定理优化快速冥取模 /******************* @function int Format_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-6 09:48:44 @param a @param n @param __MOD modulo @return a^n % __MOD *******************/ int Format_pow(int a, int n, int __MOD){ if(gcd(a, __MOD) == 1){ return quick_pow(a, n % (__MOD - 1), __MOD); } return quick_pow(a, n, __MOD); }","excerpt":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://yoursite.com/tags/信息安全/"}]},{"title":"hexo+Github搭建个人博客","date":"2017-03-29T11:43:18.000Z","path":"2017/03/29/hexo-Github搭建个人博客/","text":"&lt;未完待续&gt;","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/tags/环境配置/"}]},{"title":"小计","date":"2017-03-29T09:03:07.000Z","path":"2017/03/29/小计/","text":"NLPer","excerpt":"","categories":[],"tags":[{"name":"小小的思考","slug":"小小的思考","permalink":"http://yoursite.com/tags/小小的思考/"}]}]