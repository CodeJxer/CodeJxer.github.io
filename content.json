[{"title":"自动生成钢琴纯音乐","date":"2018-01-22T15:29:15.000Z","path":"2018/01/22/自动生成钢琴纯音乐/","text":"欢乐颂简谱 乐理基础音名：C、D、E、F、G、A、B；唱名：Do、Re、Mi、Fa、Sol、La、Si； 通常简谱采用的是首调唱名法，就是定调时会标注1=D 或 1=G 什么的，这样1，2，3，4，5，6，7就代表从D 或G 这个音高开始的Do、Re、Mi、Fa、Sol、La、Si七声音阶；1=C时： 1，2，3，4，5，6，7对应的音名就是C、D、E、F、G、A、B； 1=D时：1，2，3，4，5，6，7对应的音名就是D、E、#F、G、A、B、#C；1=E时：1，2，3，4，5，6，7对应的音名就是E、#F、#G、A、B、#C、#D；1=F时：1，2，3，4，5，6，7对应的音名就是F、G、A、bB、C、D、E；1=G时：1，2，3，4，5，6，7对应的音名就是G、A、B、C、D、E、#F；1=A时：1，2，3，4，5，6，7对应的音名就是A、B、#C、D、E、#F、#G。","excerpt":"","categories":[],"tags":[{"name":"音频处理","slug":"音频处理","permalink":"http://yoursite.com/tags/音频处理/"}]},{"title":"博客目录(索引)","date":"2018-01-22T13:32:12.000Z","path":"2018/01/22/博客目录-索引/","text":"博客文章目录 分类目录 自然语言处理 图像处理 音频处理 AGpiano-music自动生成钢琴曲 python库的学习与记录 内建库 os模块 sys模块 random模块 第三方库 pydub numpy request 前端开发 后台开发 《Flask-Web开发》学习笔记 数据库 关于此博客 使用yilia主题的过程中遇到的问题 hexo+github搭建个人博客 PyQt 算法题练习 Linux编程 Linux编程 Android开发 机器学习 爬虫 MOOC课程《Python网络爬虫与信息提取》的学习笔记 程序员 vim 开源协议 信息安全 密码学的数学基础 云端密码管理软件 计算机网络 HTTP协议 华为模拟器","excerpt":"博客文章目录","categories":[],"tags":[{"name":"关于此博客","slug":"关于此博客","permalink":"http://yoursite.com/tags/关于此博客/"}]},{"title":"Github介绍以及初步使用","date":"2018-01-22T12:32:19.000Z","path":"2018/01/22/Github介绍以及初步使用/","text":"1.Github介绍gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 2.注册Github账号2.1 点击此处跳转到Github注册界面 → Github注册2.2 填写注册信息 ### 2.验证邮箱 √3.添加ssh验证 √","excerpt":"1.Github介绍gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。","categories":[],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://yoursite.com/tags/程序员/"}]},{"title":"安装nodejs","date":"2018-01-22T12:08:12.000Z","path":"2018/01/22/安装nodejs/","text":"1.进入官网，选择对应版本下载点此处打开node.js官网 → Node.js官网 进入官网之后点击DOWNLOADS页面选择相应的版本下载即可： .msi文件有安装引导程序，会更方便一些 2.安装下载完成后双击运行下载完成的.msi文件，弹出安装引导程序：2.1安装引导程序-Next 2.2许可协议界面-同意之后Next 2.3选择安装路径-Next 这里你可以更改node.js的存储路径 2.4自定义安装-Next 2.5准备就绪-Install 2.6安装中-等待安装完毕 2.7安装完成-Finish 3.Windows平台下检查是否正确配置Home + R 然后 cmd 呼出控制台, 执行： node -v 如果返回node的版本就说明node已经加到系统的PATH中，可以在任何地方运行node相关命令 如果提示 &apos;node&apos; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 需要把你刚才安装node的路径添加到系统path变量中。","excerpt":"1.进入官网，选择对应版本下载点此处打开node.js官网 → Node.js官网 进入官网之后点击DOWNLOADS页面","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"}]},{"title":"开源协议","date":"2018-01-20T14:24:10.000Z","path":"2018/01/20/开源协议/","text":"为什么要代码开源一般而言一个真正优秀的项目往往很难凭一己之力开发出来，除了那些实力可以吊打整个银河系的coder(膜拜)。开源代码最成功的先例就是linux OS，对于开源的linux OS，用户可以通过网络或其他途径免费获得，并可以任意修改其源代码。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数程序员参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。 手机操作系统Android的蓬勃发展也离不开开源的助推力，这样的例子数不胜数。 开源协议GPLGPL，是GNU General Public License的缩写，是GNU通用公共授权非正式的中文翻译。它并非由自由软件基金会所发表，亦非使用GNU通用公共授权的软件的法定发布条款─只有GNU通用公共授权英文原文的版本始具有此等效力。GPL协议最主要的几个原则： 1、确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。 2、GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。 3、无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。 4、开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。 MPLMPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个活口。 MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 BSDBSD许可证原先是用在加州大学柏克利分校发表的各个4.4BSD/4.4BSD-Lite版本上面（BSD是Berkly Software Distribution的简写）的，后来也就逐渐沿用下来。1979年加州大学伯克利分校发布了BSD Unix，被称为开放源代码的先驱，BSD许可证就是随着BSD Unix发展起来的。BSD许可证被Apache和BSD操作系统等开源软件所采纳。 相较于GPL许可证和MPL许可证的严格性，BSD许可证就宽松许多了，一样是只需要附上许可证的原文，不过比较有趣的是，它还要求所有进一步开发者将自己的版权资料放上去，所以拿到以BSD许可证发行的软件可能会遇到一个小状况，就是这些版权资料许可证占的空间比程序还大。 QPLQPL是The Qt Public License的简称，是挪威一家机构创设的。QPL许可证的基本要求是获得源代码、修改源代码，并可将修改从原始代码中分离出来;修改可以按照作者的意愿被组合到新版本中;二进制代码可以和原始代码同名，这一点对于动态连接库来说尤其重要;任何人都可以修正错误，这对于系统的发布者来说很关键;修改过的软件可以按照满足QPL许可证基本要求的任何开源软件许可证进行发布。 QNCLQNCL许可证是Qt Non Commercial License的简称，是QPL许可证的“兄弟版”，就像GPL许可证与LGPL许可证的关系一样，QNCL许可证比QPL许可证更严格一些。 在修改和发布方面的规定，QNCL许可证与QPL许可证是一样的，差异就在于软件的范围方面，或者说在连接方面。QNCL许可证规定“假如一个应用程序给你提供了一个入口，使你有权使用QNCL许可证下的软件的功能开发程序、重复使用程序的某一部分或其他软件的某一部分，那么对该应用程序的使用视为是使用QNCL许可证下的软件的行为，该应用程序应受到QNCL许可证的约束”。QNCL许可证比QPL许可证更严格之处在于，QNCL许可证像GPL许可证那样，完全禁止根据本许可证得到的开放源码软件与其他非系统库函数连接的软件以其他许可方式一起发布。 JabJabber许可证的全称是Jabber Open Source License，由美国Jabber.Com, Inc.公司提供。Jabber许可证在源代码的复制、发行规定方面基本上和其他许可证没有什么特别，但有一些细节规定值得借鉴: 可以将通过该许可证获得的源代码及修改过的源代码与其他类型的不受该许可证约束的代码结合，以新产品的形式发布，只要其中经该许可证获得的源代码及修改过的源代码能以与该许可证的要求类似的、符合OSI认证的其他开源软件许可证的方式发布。 明确了需将源代码置于公众可以得到的状态的时间至少应为12个月。 第三方对法定权利的声明。假如使用者发现通过本许可证获得的源代码及应用程序接口中有一方拥有的知识产权，应单独在源码的发布时冠以“LEGAL”为抬头的声明，写明知识产权权利要求的细节，提请源代码的接受者知道自己获得了哪些知识产权的授权，让源码的接受者知道如何与知识产权权利人联系。 细化了该许可证终止的情形，包括不按该许可证的要求发布和使用源代码、发生专利侵权诉讼。 Com 规定可以将源代码及修改过的源代码与其他类型的不受本许可证约束的代码结合，以新产品的形式发布，只要其中经该许可证获得的源代码及修改过的源代码能按该许可证的要求发布即可。 细化了该许可证终止的情形，包括发生专利侵权诉讼。 明确了一个独立承担责任的原则，就是假如按该许可证使用源代码的使用者将获得的源代码应用于商业使用，那么他就要对在商业应用中出现的由于使用该源代码程序而产生的侵权诉讼承担完全责任。这一条规定是比较特殊的，绝大多数开源软件许可证都不这么要求。 IBMIBM许可证的全称是IBM Public License。在满足OSIA开源软件许可证认证标准的前提下，IBM许可证还有如下一些细节性规定: 明确了专利授权。一般的开源软件都明确源代码的版权人将自己的修改权、复制权等版权权利向公众许可，但保留署名权，而IBM许可证在此基础上还明确假如源代码中含有专利权，源代码专利权人将复制、使用的专有权利向公众许可。 细化了该许可证终止的情形，包括不按该许可证的要求发布和使用源代码、发生专利侵权诉讼等。 像Common许可证一样，IBM许可证也明确了独立承担责任原则，即假如按该许可证使用源代码的使用者将获得的源代码应用于商业使用，那么他就要对在商业应用中出现的、由于使用该源代码程序而产生的侵权诉讼承担完全责任。 开源协议的选择世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。 开源大法好，开源得永生","excerpt":"为什么要代码开源一般而言一个真正优秀的项目往往很难凭一己之力开发出来，除了那些实力可以吊打整个银河系的coder(膜拜)。开源代码最成功的先例就是linux OS，对于开源的linux OS，用户可以通过网络或其他途径免费获得，并可以任意修改其源代码。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数程序员参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。 手机操作系统Android的蓬勃发展也离不开开源的助推力，这样的例子数不胜数。","categories":[],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://yoursite.com/tags/程序员/"}]},{"title":"Vim学习","date":"2017-05-24T08:51:14.000Z","path":"2017/05/24/Vim学习/","text":"打开/创建文件：vi filename Vim的分屏功能1、分屏启动Vim 使用小写的o参数来上下分屏（横向分屏）。 vim -on file1 file2 … 使用大写的O参数来左右分屏（纵向分屏）。 vim -On file1 file2 … 注释: n是数字，表示分成几个屏。","excerpt":"","categories":[],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://yoursite.com/tags/程序员/"}]},{"title":"华为模拟器-实验","date":"2017-05-22T12:10:08.000Z","path":"2017/05/22/华为模拟器-实验/","text":"目录 基本实验 实验一 计算机和交换机基本设置 实验二 配置端口聚合 实验三 基本VLAN设置 实验四 配置primary VLAN和secondary VLAN 实验五 交换机的镜像与生成树 实验六 路由器BootROM升级 实验七 直联路由 实验八 单臂路由 实验九 静态路由实验 实验十 动态路由实验 实验十一 访问控制列表实验 实验十二 地址转换配置 扩展实验 命令提示 理论学习 网络的发展与应用 网络互联基础 交换机原理与应用 路由器原理与应用 常见广域网协议及特点 PIX防火墙特点与应用 PIX 防火墙应用举例 #基本实验 ##实验一 计算机和交换机基本设置添加一个交换机，一个计算机，双击交换机，进入终端配置： &lt;Quidway&gt;system ;进入管理员模式 password: [Quidway]sysname S3026 ;交换机命名 [S3026]super password 111 ;设置特权密码 [S3026]user-interface vty 0 4 ;进入虚拟终端视图 [S3026-ui-vty0-4]authentication-mode password ;设置虚拟终端验证方式 [S3026-ui-vty0-4]set authentication-mode password simple 222 ;设虚拟终端的密码 [S3026-ui-vty0-4]user privilege level 3 ;设置虚拟终端的权限级别，3是最高级 [S3026-ui-vty0-4]quit ;退出虚拟终端视图 [S3026]quit ;退出管理员视图 &lt;S3026&gt;sys ;进入管理员模式 password:111 ;输入登录密码 [S3026]display currect-config ;显示当前交换机配置 [S3026]dis curr ;上述命令的简写 [S3026]vlan 2 ;添加vlan2 [S3026-vlan2]port ethernet0/2 ;将端口2添加到vlan2 [S3026-vlan2]port e0/4 to et0/6 ;将端口4-6添加到vlan2 [S3026-vlan2]quit ;退出vlan2视图 [S3026]dis vlan ;显示vlan信息 [S3026]int e0/3 ;进图端口3 [S3026-Ethernet1]port access vlan 2 ;将端口3以access方式添加到vlan2 [S3026-Ethernet1]quit ;退出端口3视图 [S3026]dis vlan ;显示vlan信息 [S3026]dis curr ;显示当前交换机信息 [S3026]interface vlan 1 ;进入vlan1视图 [S3026-Vlan-interface1]ip address 10.65.1.8 255.255.0.0;试着vlan1的ip和子网掩码 [S3026-Vlan-interface1]quit ;退出vlan1视图 [S3026]ip route-static 0.0.0.0 0.0.0.0 10.65.1.2 ;设置交换机的静态路由 [S3026]ip default-gateway 10.65.1.2 ;设置交换机的默认网关 [S3026]dis curr ;显示当前配置信息 [S3026]save ;保存 双击小电脑： login:root ;登录主机 password:linux ;输入登录密码 [root@PCA root]#ifconfig eth0 10.65.1.1 netmask 255.255.0.0;设置ip和子网掩码 [root@PCA root]#ifconfig ;显示ip设置 [root@PCA root]#route add default gw 10.65.1.2;设置默认网关 [root@PCA root]#route ;显示网关设置 [root@PCA root]#ping 10.65.1.8 ;向10.65.1.8发送ECHO包 [root@PCA root]#telnet 10.65.1.8 ;远程登录10.65.1.8 ##实验二 配置端口聚合要求聚合的端口工作在全双工，速度一致，在同一槽口且连续。参数：ingress:源MAC, both:源和目的MAC 对于SwitchA: [Quidway]sysname SwitchA ;给交换机命令 [SwitchA]interface ethernet0/1 ;进入端口1视图 [SwitchA-Ethernet0/1]duplex full ;设置为全双工模式 [SwitchA-Ethernet0/1]speed 100 ;速度为100 [SwitchA-Ethernet0/1]port link-type trunk ;设置端口连接类型为trunk [SwitchA-Ethernet0/1]port trunk permit vlan all ;设置允许所有vlan通过 [SwitchA-Ethernet0/1]int e0/2 ;进入端口2视图 [SwitchA-Ethernet0/2]duplex full ;设置为全双工模式 [SwitchA-Ethernet0/2]speed 100 ;速度为100 [SwitchA-Ethernet0/2]port link-type trunk ;设置端口类型为trunk [SwitchA-Ethernet0/2]port trunk permit vlan all ;设置允许所有vlan通过 对于SwitchB: [Quidway]sysname SwitchB ;为交换机命令 [SwitchB]interface ethernet0/1 ;进图端口1视图 [SwitchB-Ethernet0/1]duplex full ;设置为全双工模式 [SwitchB-Ethernet0/1]speed 100 ;速度为100 [SwitchB-Ethernet0/1]port link-type trunk ;设置端口连接为trunk [SwitchB-Ethernet0/1]port trunk permit vlan all ;允许所有vlan通过 [SwitchB-Ethernet0/1]int e0/2 ;进入端口2视图 [SwitchB-Ethernet0/2]duplex full ;设置为全双工模式 [SwitchB-Ethernet0/2]speed 100 ;速度为100 [SwitchB-Ethernet0/2]port link-type trunk ;设置端口连接类型为trunk [SwitchB-Ethernet0/2]port trunk permit vlan all ;允许所有类型的vlan通过 聚合操作： [SwitchA]link-aggregation ethernet0/1 to ethernet0/2 both ;将端口1到端口2聚合 [SwitchB]link-aggregation ethernet0/1 to ethernet0/2 both ;将端口1到端口2聚合 [SwitchA]display link-aggregation ethernet0/1 ;显示聚合信息 [SwitchA]undo link-aggregation all ;取消所有聚合 ##实验三 基本VLAN设置 [SwitchA]vlan 2 ;添加vlan2 [SwitchA-vlan2]port e0/3 to e0/4 ;将端口3-4添加到vlan2 [SwitchA-vlan2]vlan 3 ;添加vlan3 [SwitchA-vlan3]port e0/5 to e0/6 ;将端口5-6添加到vlan3 [SwitchA]dis vlan all ;显示所有vlan信息 [SwitchA]dis current ;显示当前配置信息 [SwitchB]vlan 2 ;添加vlan2 [SwitchB-vlan2]port e0/3 to e0/4 ;将端口3-4添加到vlan2 [SwitchB-vlan2]vlan 3 ;添加vlan3 [SwitchB-vlan3]port e0/5 to e0/6 ;将端口5-6添加到vlan3 [SwitchB-vlan3]quit ;退出vlan视图 [SwitchB]dis vlan all ;显示所有vlan信息 [SwitchB]dis current ;显示所有配置信息 设置计算机的IP为： PCA:10.65.1.1 PCB:10.66.1.1 PCC:10.65.1.3 PCD:10.66.1.3 [root@PCA root]ifconfig eth0 10.65.1.1 netmask 255.255.0.0 [root@PCB root]ifconfig eth0 10.66.1.1 netmask 255.255.0.0 [root@PCC root]ifconfig eth0 10.65.1.3 netmask 255.255.0.0 [root@PCD root]ifconfig eth0 10.66.1.3 netmask 255.255.0.0 [root@PCA root]#ping 10.65.1.1 通 (本机IP) [root@PCA root]#ping 10.65.1.3 不通 (中间连接线是vlan 1) [root@PCA root]#ping 10.66.1.1 不通 (不同网络，不同vlan) [root@PCA root]#ping 10.66.1.3 不通 (不同网络，不同vlan) [root@PCB root]#ping 10.66.1.3 不通 (中间连接线是vlan 1) 将PCA改接到SwitchA E0/2 (vlan 1) [root@PCA root]#ping 10.65.1.3 不通 (同网络，不同vlan) 将PCC改接到SwitchB E0/2 (vlan 1) [root@PCA root]#ping 10.65.1.3 通 (同网络，同在vlan 1) 再改回来，并设置trunk: [S3026A]interface ethernet0/8 ;进入端口8视图 [S3026A-Ethernet0/8]port link-type trunk ;设置端口类型为trunk [S3026A-Ethernet0/8]port trunk permit vlan all ;允许所有vlan通过 [S3026B]interface ethernet0/1 ;进图端口1 [S3026B-Ethernet0/1]port link-type trunk ;设置端口类型为trunk [S3026B-Ethernet0/1]port trunk permit vlan all ;允许所有vlan通过 [S3026B-Ethernet0/1]quit ;退出端口视图 [S3026B]dis curr ;显示当前所有配置信息 [root@PCA root]#ping 10.65.1.3 通 ;属于同一个vlan [root@PCA root]#ping 10.66.1.3 不通 ;不同网络，不同vlan [root@PCB root]#ping 10.66.1.3 通 ;属于同一个vlan 即：PCA和PCC同在vlan 2 是通的，PCB和PCD同在vlan 3是通的。 PCA和PCB是不通的。同理PCC和PCD也是不通的。 ------------------------------------------------------------ 再加入一个交换机switchC，将它串入switchA和switchB之间，连接方式： switchA:E0/8--&gt;switchC:E0/3; switchC:E0/6--&gt;switchB:E0/1 (1) 新加入的SwitchC 默认状态时，测试连通性。 从PCA-&gt;PCC，从PCB-&gt;PCD 测试： [root@PCA root]# ping 10.65.1.3 (不通) [root@PCB root]# ping 10.66.1.3 (不通) 由于新加入的交换机没有设置trunk，端口默认vlan 1，交换机的trunk 要成对出现，因为当dot1q不能和另一端交换信息时，会自动down掉。 (2) 将交换机之间的连线都设置成trunk时，再测试连通性。 [S3026C]interface ethernet0/3 ;进入端口3视图 [S3026C-Ethernet0/1]port link-type trunk ;设置端口类型为trunk [S3026C-Ethernet0/1]port trunk permit vlan all ;允许所有vlan通过 [S3026C]interface ethernet0/6 ;进入端口6视图 [S3026C-Ethernet0/8]port link-type trunk ;设置端口类型为trunk [S3026C-Ethernet0/8]port trunk permit vlan all ;允许所有vlan通过 现在有两条正确的trunk,再看一下联通情况： [root@PCA root]# ping 10.65.1.3 （通） ;属于同一个vlan [root@PCB root]# ping 10.66.1.3 （通） ;属于用一个vlan (3) 设置vtp VTP是vlan 传输协议，在VTP Server上配置的vlan 在条件允许条件下，可以 从VTP Client 端看到VTP Server上的vlan，并将自己端口加入到vlan中。 [S3026C]vtp domain abc ;设置vtp名称 [S3026C]vtp mode server ;设置vtp模式为server [S3026C]vtp password ok ;设置密码为ok [S3026B]vtp domain abc ;设置vtp名称 [S3026B]vtp mode client ;设置vtp模式为client [S3026B]vtp password ok ;设置密码为ok [S3026A]#disp vlan ;显示交换机A的所有vlan信息 [S3026B]#disp vlan ;显示交换机B的所有vlan信息 [S3026C]#disp vlan ;显示交换机C的所有vlan信息 当口令和域名一致时，client端可以学习到server端的vlan，在VTP Server端还 可以有很多策略，这里只是说明最基本的问题。 VTP在企业、机关、学校的应用是很多的，在主交换机上设置好vlan以后，下级的 交换机不用再设置vlan，可以将client的某些端口添加到VTP Server中定义的vlan中 去，加强了管理。 ##实验四 配置primary VLAN和secondary VLAN主附vlan一般用于一个网络段的情况，主vlan和子vlan间可以访问，而子vlan之间是不能访问的。 设置计算机的IP为： PCA:10.65.1.1 PCB:10.65.1.2 PCC:10.65.1.3 PCD:10.65.1.4 [root@PCA root]ifconfig eth0 10.65.1.1 netmask 255.255.0.0 [root@PCB root]ifconfig eth0 10.65.1.2 netmask 255.255.0.0 [root@PCC root]ifconfig eth0 10.65.1.3 netmask 255.255.0.0 [root@PCD root]ifconfig eth0 10.65.1.4 netmask 255.255.0.0 [SwitchA]vlan 2 ;添加vlan2 [SwitchA-vlan2]port ethernet 0/5 to ethernet 0/6;将端口5-6添加到vlan2 [SwitchA]vlan 3 ;添加vlan3 [SwitchA-vlan3]port ethernet 0/7 to ethernet 0/8;将端口7-8添加到vlan3 [SwitchA]vlan 5 ;添加vlan5 [SwitchA-vlan5]port ethernet 0/1 to ethernet 0/4;将端口1-4添加到vlan5 [SwitchA-vlan5]isolate-user-vlan enable ;将vlan5设置为主vlan [SwitchA-vlan5]quit ;退出vlan5视图 [SwitchA]isolate-user-vlan 5 secondary 2,3 ;将vlan2,3设置Wie子vlan [SwitchB]vlan 2 ;添加vlan2 [SwitchB-vlan2]port ethernet 0/5 to ethernet 0/6;将端口5-6添加到vlan2 [SwitchB]vlan 3 ;添加vlan3 [SwitchB-vlan3]port ethernet 0/7 to ethernet 0/8;将端口7-8添加到vlan3 [SwitchA]vlan 4 ;添加vlan4 [SwitchB-vlan4]port ethernet 0/1 to ethernet 0/4;将端口1-4添加到vlan4 [SwitchB-vlan4]isolate-user-vlan enable ;将vlan4设置为主vlan [SwitchB-vlan4]quit ;退出vlan4视图 [SwitchB]isolate-user-vlan 4 secondary 2,3 ;将vlan2,3设置为子vlan ##实验五 交换机的镜像与生成树 (一) 设置镜像 镜像是一个端口的数据被映射到另一个端口，进行数据分析。 [Quidway]monitor-port e0/8 ;设置观测端口 [Quidway]port mirror e0/1 ;设置被观测端口 或： [Quidway]port mirror e0/1 to e0/2 observing-port e0/8;一次性设置观测与被观测端口 (二) 生成树 [Quidway]stp {enable|disable} ;{启动|关闭}生成树 [Quidway]stp priority 4096 ;设置交换机的优先级 [Quidway]stp root primary ;设置交换机为树根 [Quidway-Ethernet0/1]stp cost 200 ;设置交换机端口的花费 ##实验六 路由器BootROM升级 &lt;Quidway&gt;system [Quidway]reload Press Ctrl+B to enter Boot Menu … Boot Menu: 1:Download application program 2:Download Bootrom program 3:Modify Bootrom password 4:Exit menu 5:Reboot Enter your choice(1-5):1 Downloading application program from serial ... (rs232) please choose your download speed: 1:9600bps 2:19200bps 3:38400bps 4:Exit and reboot Enter your choice(1-4):2 Download speed is 38400bps. Please change the terminal&apos;s speed to 38400bps. And select XMODEM protocol. Press ENTER key when ready. Downloading ...CC (please select [File]-&gt;[Send]) ############################################################ ############################################################ ############################################################ ########### ok! Download completed. Write flash auccessfully! [Quidway] ##实验七 直联路由 &lt;Quidwqy&gt;system ;进入管理员模式 password: [Quidway]interface ethernet0 ;进入端口0视图 [Quidway-Ethernet0]ip addr 10.65.1.2 255.255.255.0 ;设置端口0IP地址 [Quidway-Ethernet0]undo shutdown ;启动端口0 [Quidway-Ethernet0]int e1 ;进入端口1 [Quidway-Ethernet1]ip addr 10.66.1.2 255.255.255.0 ;设置端口1IP地址 [Quidway-Ethernet1]undo shutdown ;启动端口1 [root@PCA root]#ifconfig eth0 10.65.1.1 netmask 255.255.0.0 ;设置主机AIP [root@PCB root]#ifconfig eth0 10.66.1.1 netmask 255.255.0.0 ;设置主机BIP [root@PCA root]#ping 10.65.1.2 (不通，没有关只能ping直连的口) [root@PCA root]#ping 10.66.1.2 (不通，PCA 没有设置网关) [root@PCA root]#route add default gw 10.65.1.2 ;设置主机A网关 [root@PCA root]#ping 10.66.1.2 (通) [root@PCA root]#ping 10.66.1.1 (不通，因PCB没有网关) [root@PCB root]#route add default gw 10.66.1.2 ;设置主机B网关 [root@PCA root]#ping 10.66.1.1 (通) 去掉计算机Host B与Router的连线，再ping： [root@PCA root]#ping 10.66.1.2 不通(没有接线端口会自动down掉) 再连接Host B与Router的连线，再ping: [root@PCA root]#ping 10.66.1.2 (通) ##实验八 单臂路由 设置PCA ip:10.65.1.1 gateway:10.65.1.2 设置PCB ip:10.66.1.1 gateway:10.66.1.2 [root@PCA root]#ifconfig eth0 10.65.1.1 netmask 255.255.0.0 [root@PCA root]#route add default gw 10.65.1.2 [root@PCB root]#ifconfig eth0 10.66.1.1 netmask 255.255.0.0 [root@PCB root]#route add default gw 10.66.1.2 1.一个接口两个IP的情况 &lt;Quidwqy&gt;system ;进入管理员模式 password: [Quidway]interface ethernet0 ;进入接口0视图 [Quidway-Ethernet0]ip addr 10.65.1.2 255.255.255.0 ;设置IP [Quidway-Ethernet1]ip addr 10.66.1.2 255.255.255.0 secondary ;设置IP [Quidway-Ethernet1]undo shutdown ;启动 [root@PCA root]#ping 10.66.1.1 通 2．划分两个子接口，对两个vlan的路由 [SwitchA]vlan 2 ;添加vlan2 [SwitchA-vlan2]port e0/3 ;将端口3添加到vlan2 [SwitchA]vlan 3 ;添加vlan3 [SwitchA-vlan3]port e0/6 ;将端口6添加到vlan3 [SwitchA]int e0/1 ;进入端口1 [SwitchA-Ethernet0/1]port link-type trunk ;设置端口类型为trunk [SwitchA-Ethernet0/1]port trunk permit vlan all ;允许所有vlan通过 [SwitchA-Ethernet0/1]port trunk encap dot1q ;设置trunk封装协议为dot1q [SwitchA]dis curr [Quidway]int e0 ;进入端口0 [SwitchA-Ethernet0]int e0.1 ;进入端口0.1 [SwitchA-Ethernet0.1]encapsulation dot1q 2 ;设置封装格式为dot1q [SwitchA-Ethernet0.1]ip addr 10.65.1.2 255.255.255.0;设置IP [SwitchA-Ethernet0.1]undo shut ;启动 [SwitchA-Ethernet0.1]int e0.2 ;进入端口0.2 [SwitchA-Ethernet0.2]encapsulation dot1q 2 ;设置封装格式为dot1q [SwitchA-Ethernet0.2]ip addr 10.66.1.2 255.255.255.0;设置IP [SwitchA-Ethernet0.2]undo shut ;启动 [SwitchA]dis curr [root@PCA root]#ping 10.66.1.1 通 ##实验九 静态路由实验 PCA:10.65.1.1 PCB:10.66.1.1 PCC:10.70.1.1 PCD:10.71.1.1 [root@PCA root]#ifconfig eth0 10.65.1.1 netmask 255.255.0.0 [root@PCB root]#ifconfig eth0 10.66.1.1 netmask 255.255.0.0 [root@PCC root]#ifconfig eth0 10.70.1.1 netmask 255.255.0.0 [root@PCD root]#ifconfig eth0 10.71.1.1 netmask 255.255.0.0 [RouterA]interface ethernet0 ;进入端口0 [RouterA-Ethernet0]ip addrress 10.65.1.2 255.255.0.0 [RouterA-Ethernet0]undo shutdown [RouterA-Ethernet0]int e1 [RouterA-Ethernet1]ip addrress 10.66.1.2 255.255.0.0 [RouterA-Ethernet1]undo shutdown [RouterA-Ethernet1]int s1 [RouterA-Serial1]ip addrress 10.68.1.2 255.255.0.0 [RouterA-Serial1]undo shutdown [RouterA-Serial1]clock rate 64000 [RouterA-Serial1]quit [RouterA]ip routing [RouterA]dis curr [RouterB]interface ethernet0 [RouterB-Ethernet0]ip addrress 10.70.1.2 255.255.0.0 [RouterB-Ethernet0]undo shutdown [RouterB-Ethernet0]int e1 [RouterB-Ethernet1]ip addrress 10.71.1.2 255.255.0.0 [RouterB-Ethernet1]undo shutdown [RouterB-Ethernet1]int s0 [RouterB-Serial0]ip addrress 10.68.1.1 255.255.0.0 [RouterB-Serial0]undo shutdown [RouterB-Serial0]quit [RouterB]ip routing [RouterB]dis curr [root@PCA root]#ifconfig eth0 10.65.1.1 netmask 255.255.0.0 [root@PCA root]#route add default gw 10.65.1.2 [root@PCA root]#ping 10.65.1.2 通 [root@PCA root]#ping 10.66.1.2 通 [root@PCA root]#ping 10.67.1.2 通 [root@PCA root]#ping 10.68.1.2 不通 [root@PCA root]#ping 10.69.1.2 不通 [RouterA]ip route-static 10.69.0.0 255.255.0.0 10.67.1.1 [root@PCA root]#ping 10.69.1.1 通 三个路由器的静态路由 (参考实验九图) 设置RouterA的IP: f0/0: 10.65.1.2 ---&gt;PCA:10.65.1.1 f0/1: 10.66.1.2 ---&gt;PCB:10.66.1.1 s0/0: 10.67.1.2 s0/1: 10.68.1.2 ---&gt;接RouterC s0/0 设置RouterC的IP: s0/0: 10.68.1.1 &lt;--- s0/1: 10.78.1.2 ---&gt;接RouterB s0/0 设置RouterB的IP: s0/0: 10.78.1.1 &lt;--- s0/1: 10.67.1.1 f0/0: 10.69.1.2 ---&gt;PCC:10.69.1.1 f0/1: 10.70.1.2 ---&gt;PCD:10.70.1.1 设置从PCA到PCC的静态路由 [ROA]ip routing [ROA]ip route-static 10.69.0.0 255.255.0.0 10.68.1.1 [ROA]display ip route [ROB]ip route-static 10.69.0.0 255.255.0.0 10.78.1.1 [ROB]display ip route [root@PCA root]#ping 10.69.1.1 (通) [root@PCA root]#ping 10.78.1.1 (不通) [root@PCA root]#ping 10.70.1.1 (不通) 为什么PCA 到10.78.1.1不通呢？它是去10.69.1.1要经过的地方啊，这是由于在 RouterA上，没有去10.78.0.0网络的路由，所以到这个网络它不知道要向哪去送。 如何让PCA到10.70.1.1 (PCD)通呢，像10.69.0.0网络一样，在路径的路由器上 ， 再各写一条到10.70.0.0网络的静态路由就可以了。 如果每一条路径都写一组静态路由显然不好，由于PCA在这个网络中实际只有一条 主通路，所以使用默认路由较好。 我们再做一个使用默认路由的小实验，先去掉原有的静态路由。 [ROA]undo ip route-static 10.69.0.0 255.255.0.0 10.68.1.1 [ROA]display ip route [ROA]undo ip route-static 10.69.0.0 255.255.0.0 10.78.1.1 [ROB]display ip route [root@PCA root]#ping 10.69.1.1 (不通) [ROA]ip route-static 0.0.0.0 0.0.0.0 10.68.1.1 [ROB]display ip route [ROB]ip route-static 0.0.0.0 0.0.0.0 10.69.1.1 [ROB]display ip route [root@PCA root]#ping 10.69.1.1 (通) [root@PCA root]#ping 10.70.1.1 (通) [root@PCA root]#ping 10.78.1.1 (通) 路由表是路由器实现路由的指导思想。到一个网络通不通，要看路由表中有没有去 目的网络的路由表项，动态路由可以自动创建路由表，定时更新。 [RouterB-Serial0]undo ip addrress 10.67.1.1 255.255.0.0 [RouterB-Serial0]ip addrress 10.70.1.1 255.255.0.0 [RouterC]interface serial0 [RouterC-Serial0]ip addrress 10.67.1.1 255.255.0.0 [RouterC-Serial0]undo shutdown [RouterC-Serial0]clock rate 64000 [RouterC-Serial0]int s1 [RouterC-Serial1]ip addrress 10.70.1.1 255.255.0.0 [RouterC-Serial1]undo shutdown [RouterC-Serial1]quit [RouterC]ip route-static 10.69.0.0 255.255.0.0 10.70.1.1 [RouterC]dis curr [root@PCA root]#ping 10.69.1.1 通 [root@PCA root]#ping 10.68.1.1 不通 ##实验十 动态路由实验 ##实验十一 访问控制列表实验 ##实验十二 地址转换配置 #扩展实验 #命令提示 计算机命令 12345678910111213141516171819PCA login: root ；使用root用户 password: linux ；口令是linux# shutdown -h now ；关机# init 0 ；关机# logout ；用户注销# login ；用户登录# ifconfig ；显示IP地址# ifconfig eth0 &lt;ip address&gt; netmask &lt;netmask&gt; ；设置IP地址# ifconfig eht0 &lt;ip address&gt; netmask &lt;netmask&gt; down ；禁用IP地址# route add 0.0.0.0 gw &lt;ip&gt; ；设置网关# route del 0.0.0.0 gw &lt;ip&gt; ；删除网关# route add default gw &lt;ip&gt; ；设置网关# route del default gw &lt;ip&gt; ；删除网关# route ；显示网关# ping &lt;ip&gt; ；发ECHO包# telnet &lt;ip&gt; ；远程登录－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－交换机命令 [Quidway]dis cur ；显示当前配置 [Quidway]display current-configuration ；显示当前配置 [Quidway]display interfaces ；显示接口信息 [Quidway]display vlan all ；显示路由信息 [Quidway]display version ；显示版本信息 [Quidway]super password ；修改特权用户密码 [Quidway]sysname ；交换机命名 [Quidway]interface ethernet 0/1 ；进入接口视图 [Quidway]interface vlan x ；进入接口视图 [Quidway-Vlan-interfacex]ip address 10.65.1.1 255.255.0.0 ；配置VLAN的IP地址 [Quidway]ip route-static 0.0.0.0 0.0.0.0 10.65.1.2 ；静态路由＝网关 [Quidway]rip ；三层交换支持 [Quidway]local-user ftp [Quidway]user-interface vty 0 4 ；进入虚拟终端 [S3026-ui-vty0-4]authentication-mode password ；设置口令模式 [S3026-ui-vty0-4]set authentication-mode password simple 222 ；设置口令 [S3026-ui-vty0-4]user privilege level 3 ；用户级别 [Quidway]interface ethernet 0/1 ；进入端口模式 [Quidway]int e0/1 ；进入端口模式 [Quidway-Ethernet0/1]duplex {half|full|auto} ；配置端口工作状态 [Quidway-Ethernet0/1]speed {10|100|auto} ；配置端口工作速率 [Quidway-Ethernet0/1]flow-control ；配置端口流控 [Quidway-Ethernet0/1]mdi {across|auto|normal} ；配置端口平接扭接 [Quidway-Ethernet0/1]port link-type {trunk|access|hybrid} ；设置端口工作模式 [Quidway-Ethernet0/1]port access vlan 3 ；当前端口加入到VLAN [Quidway-Ethernet0/2]port trunk permit vlan {ID|All} ；设trunk允许的VLAN [Quidway-Ethernet0/3]port trunk pvid vlan 3 ；设置trunk端口的PVID [Quidway-Ethernet0/1]undo shutdown ；激活端口 [Quidway-Ethernet0/1]shutdown ；关闭端口 [Quidway-Ethernet0/1]quit ；返回 [Quidway]vlan 3 ；创建VLAN [Quidway-vlan3]port ethernet 0/1 ；在VLAN中增加端口 [Quidway-vlan3]port e0/1 ；简写方式 [Quidway-vlan3]port ethernet 0/1 to ethernet 0/4 ；在VLAN中增加端口 [Quidway-vlan3]port e0/1 to e0/4 ；简写方式 [Quidway]monitor-port &lt;interface_type interface_num&gt; ；指定镜像端口 [Quidway]port mirror &lt;interface_type interface_num&gt; ；指定被镜像端口 [Quidway]port mirror int_list observing-port int_type int_num ；指定镜像和被镜像 [Quidway]description string ；指定VLAN描述字符 [Quidway]description ；删除VLAN描述字符 [Quidway]display vlan [vlan_id] ；查看VLAN设置 [Quidway]stp {enable|disable} ；设置生成树,默认关闭 [Quidway]stp priority 4096 ；设置交换机的优先级 [Quidway]stp root {primary|secondary} ；设置为根或根的备份 [Quidway-Ethernet0/1]stp cost 200 ；设置交换机端口的花费 [Quidway]link-aggregation e0/1 to e0/4 ingress|both ; 端口的聚合 [Quidway]undo link-aggregation e0/1|all ; 始端口为通道号 [SwitchA-vlanx]isolate-user-vlan enable ；设置主vlan [SwitchA]isolate-user-vlan &lt;x&gt; secondary &lt;list&gt; ；设置主vlan包括的子vlan [Quidway-Ethernet0/2]port hybrid pvid vlan &lt;id&gt; ；设置vlan的pvid [Quidway-Ethernet0/2]port hybrid pvid ；删除vlan的pvid [Quidway-Ethernet0/2]port hybrid vlan vlan_id_list untagged ；设置无标识的vlan 如果包的vlan id与PVId一致，则去掉vlan信息. 默认PVID=1。 所以设置PVID为所属vlan id, 设置可以互通的vlan为untagged. －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 路由器命令 ~~~~~~~~~~ [Quidway]display version ；显示版本信息 [Quidway]display current-configuration ；显示当前配置 [Quidway]display interfaces ；显示接口信息 [Quidway]display ip route ；显示路由信息 [Quidway]sysname aabbcc ；更改主机名 [Quidway]super passwrod 123456 ；设置口令 [Quidway]interface serial0 ；进入接口 [Quidway-serial0]ip address &lt;ip&gt; &lt;mask|mask_len&gt; ；配置端口IP地址 [Quidway-serial0]undo shutdown ；激活端口 [Quidway]link-protocol hdlc ；绑定hdlc协议 [Quidway]user-interface vty 0 4 [Quidway-ui-vty0-4]authentication-mode password [Quidway-ui-vty0-4]set authentication-mode password simple 222 [Quidway-ui-vty0-4]user privilege level 3 [Quidway-ui-vty0-4]quit [Quidway]debugging hdlc all serial0 ；显示所有信息 [Quidway]debugging hdlc event serial0 ；调试事件信息 [Quidway]debugging hdlc packet serial0 ；显示包的信息 静态路由： [Quidway]ip route-static &lt;ip&gt;&lt;mask&gt;{interface number|nexthop}[value][reject|blackhole] 例如： [Quidway]ip route-static 129.1.0.0 16 10.0.0.2 [Quidway]ip route-static 129.1.0.0 255.255.0.0 10.0.0.2 [Quidway]ip route-static 129.1.0.0 16 Serial 2 [Quidway]ip route-static 0.0.0.0 0.0.0.0 10.0.0.2 动态路由： [Quidway]rip ；设置动态路由 [Quidway]rip work ；设置工作允许 [Quidway]rip input ；设置入口允许 [Quidway]rip output ；设置出口允许 [Quidway-rip]network 1.0.0.0 ；设置交换路由网络 [Quidway-rip]network all ；设置与所有网络交换 [Quidway-rip]peer ip-address ； [Quidway-rip]summary ；路由聚合 [Quidway]rip version 1 ；设置工作在版本1 [Quidway]rip version 2 multicast ；设版本2，多播方式 [Quidway-Ethernet0]rip split-horizon ；水平分隔 [Quidway]router id A.B.C.D ；配置路由器的ID [Quidway]ospf enable ；启动OSPF协议 [Quidway-ospf]import-route direct ；引入直联路由 [Quidway-Serial0]ospf enable area &lt;area_id&gt; ；配置OSPF区域 标准访问列表命令格式如下： acl &lt;acl-number&gt; [match-order config|auto] ；默认前者顺序匹配。 rule [normal|special]{permit|deny} [source source-addr source-wildcard|any] 例： [Quidway]acl 10 [Quidway-acl-10]rule normal permit source 10.0.0.0 0.0.0.255 [Quidway-acl-10]rule normal deny source any 扩展访问控制列表配置命令 配置TCP/UDP协议的扩展访问列表： rule {normal|special}{permit|deny}{tcp|udp}source {&lt;ip wild&gt;|any}destination &lt;ip wild&gt;|any} [operate] 配置ICMP协议的扩展访问列表： rule {normal|special}{permit|deny}icmp source {&lt;ip wild&gt;|any]destination {&lt;ip wild&gt;|any] [icmp-code] [logging] 扩展访问控制列表操作符的含义 equal portnumber ；等于 greater-than portnumber ；大于 less-than portnumber ；小于 not-equal portnumber ；不等 range portnumber1 portnumber2 ；区间 扩展访问控制列表举例 [Quidway]acl 101 [Quidway-acl-101]rule deny souce any destination any [Quidway-acl-101]rule permit icmp source any destination any icmp-type echo [Quidway-acl-101]rule permit icmp source any destination any icmp-type echo-reply [Quidway]acl 102 [Quidway-acl-102]rule permit ip source 10.0.0.1 0.0.0.0 destination 202.0.0.1 0.0.0.0 [Quidway-acl-102]rule deny ip source any destination any [Quidway]acl 103 [Quidway-acl-103]rule permit tcp source any destination 10.0.0.1 0.0.0.0 destination-port equal ftp [Quidway-acl-103]rule permit tcp source any destination 10.0.0.2 0.0.0.0 destination-port equal www [Quidway]firewall enable [Quidway]firewall default permit|deny [Quidway]int e0 [Quidway-Ethernet0]firewall packet-filter 101 inbound|outbound 地址转换配置举例 [Quidway]firewall enable [Quidway]firewall default permit [Quidway]acl 101 ;内部指定主机可以进入e0 [Quidway-acl-101]rule deny ip source any destination any [Quidway-acl-101]rule permit ip source 129.38.1.1 0 destination any [Quidway-acl-101]rule permit ip source 129.38.1.2 0 destination any [Quidway-acl-101]rule permit ip source 129.38.1.3 0 destination any [Quidway-acl-101]rule permit ip source 129.38.1.4 0 destination any [Quidway-acl-101]quit [Quidway]int e0 [Quidway-Ethernet0]firewall packet-filter 101 inbound [Quidway]acl 102 ;外部特定主机和大于1024端口的数据包允许进入S0 [Quidway-acl-102]rule deny ip source any destination any [Quidway-acl-102]rule permit tcp source 202.39.2.3 0 destination 202.38.160.1 0 [Quidway-acl-102]rule permit tcp source any destination 202.38.160.1 0 destination-port great-than 1024 [Quidway-acl-102]quit [Quidway]int s0 [Quidway-Serial0]firewall packet-filter 102 inbound ；设202.38.160.1是路由器出口IP。 [Quidway-Serial0]nat outbound 101 interface ;是Easy ip，将acl 101允许的IP从本接口出时变换源地址。 内部服务器地址转换配置命令(静态nat)： nat server global &lt;ip&gt; [port] inside &lt;ip&gt; port [protocol] ;global_port不写时使用inside_port [Quidway-Serial0]nat server global 202.38.160.1 inside 129.38.1.1 ftp tcp [Quidway-Serial0]nat server global 202.38.160.1 inside 129.38.1.2 telnet tcp [Quidway-Serial0]nat server global 202.38.160.1 inside 129.38.1.3 www tcp 设有公网IP：202.38.160.101~202.38.160.103 可以使用。 ;对外访问(原例题) [Quidway]nat address-group 202.38.160.101 202.38.160.103 pool1 ;建立地址池 [Quidway]acl 1 [Quidway-acl-1]rule permit source 10.110.10.0 0.0.0.255 ;指定允许的内部网络 [Quidway-acl-1]rule deny source any [Quidway-acl-1]int serial 0 [Quidway-Serial0]nat outbound 1 address-group pool1 ;在s0口从地址池取出IP对外访问 [Quidway-Serial0]nat server global 202.38.160.101 inside 10.110.10.1 ftp tcp [Quidway-Serial0]nat server global 202.38.160.102 inside 10.110.10.2 www tcp [Quidway-Serial0]nat server global 202.38.160.102 8080 inside 10.110.10.3 www tcp [Quidway-Serial0]nat server global 202.38.160.103 inside 10.110.10.4 smtp udp PPP设置： [Quidway-s0]link-protocol ppp ;默认的协议 PPP验证： 主验方：pap|chap [Quidway]local-user q2 password {simple|cipher} hello ;路由器1 [Quidway]interface serial 0 [Quidway-serial0]ppp authentication-mode {pap|chap} [Quidway-serial0]ppp chap user q1 ;pap时，没有此句 pap被验方： [Quidway]interface serial 0 ;路由器2 [Quidway-serial0]ppp pap local-user q2 password {simple|cipher} hello chap被验方： [Quidway]interface serial 0 ;路由器2 [Quidway-serial0]ppp chap user q2 ;自己路由器名 [Quidway-serial0]local-user q1 password {simple|cipher} hello ;对方路由器名 帧中继frame-relay (二分册6-61) [q1]fr switching [q1]int s1 [q1-Serial1]ip address 192.168.34.51 255.255.255.0 [q1-Serial1]link-protocol fr ;封装帧中继协议 [q1-Serial1]fr interface-type dce [q1-Serial1]fr dlci 100 [q1-Serial1]fr inarp [q1-Serial1]fr map ip 192.168.34.52 dlci 100 [q2]int s1 [q2-Serial1]ip address 192.168.34.52 255.255.255.0 [q2-Serial1]link-protocol fr [q2-Serial1]fr interface-type dte [q2-Serial1]fr dlci 100 [q2-Serial1]fr inarp [q2-Serial1]fr map ip 192.168.34.51 dlci 100 帧中继监测 [q1]display fr lmi-info[]interface type number] [q1]display fr map [q1]display fr pvc-info[serial interface-number][dlci dlci-number] [q1]display fr dlci-switch [q1]display fr interface [q1]reset fr inarp-info [q1]debugging fr all[interface type number] [q1]debugging fr arp[interface type number] [q1]debugging fr event[interface type number] [q1]debugging fr lmi[interface type number] 启动ftp服务： [Quidway]local-user ftp password {simple|cipher} aaa service-type ftp [Quidway]ftp server enable －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ #理论学习 ##网络的发展与应用 一、计算机网络发展的三个阶段 1、研究阶段 (68年~84年) 主要特征： TCP/IP协议的研制成功。 Client/Server工作方阿式的实现。 实现了资源共享和分散控制等。 2、运行阶段 (85年~92年) 主要特征： Internet骨干网络的延生 网络私有化的形成 网络商业化的开始 3、应用阶段 (92年~今) 主要特征： 网络发展的全球化 网络运行的商业化 网络应用的多样化 二、我国计算机网络的三个层次 1、国家经济信息化的基本通信网， CHINAPAC：1991建设，分组交换网。 CHINADDN：1994建设，数字专用网 金桥工程：1997建设，以光纤、卫星、微波、无线移动等多种方式，形成天地一体的网络结构。 2、依托此平台开发的各种专业网络和应用网络； 金卡工程：全民信用卡系统——电子货币工程。 金企工程：企业生产与流通信息系统，为国家宏观调控提供科学依据。 金农工程：农业综合管理及信息服务系统，以县城为点的农业基本情况数据库。 金关工程：国家对外经济贸易信息网。 金税工程：增值税专用发票计算机稽核系统工程。 企业网络：企业总部与分部组成的异地独立网络。 教育科研网：CERNET连接全国各大高校。 3、目前中小型企业网络的应用情况 企事业都建设了自己的局域网，而且越来越多的局域网和广域网相联。 网络硬件水平不断提高，促进了网络技术的应用，网络管理人才的需求加大。 网络管理员：以网络互联技术为主的网络人才。 操作系统管理员：以管理操作系统为主的网络人才。 线路维护人员：负责网络运行的维修人员。 网络技术支持：负责公司网络产品的技术的咨询和售后服务。 ##网络互联基础 一、OSI七层协议 OSI(Open System interconnection)开放系统互连参考模型 ISO(International Standards Organization)国际标准化组织 1、物理层 机械性能：接口的型状，尺寸的大小，引脚的数目和排列方式等。 电气性能：接口规定信号的电压、电流、阻抗、波形、速率及平衡特性等。 工程规范：接口引脚的意义、特性、标准。 工作方式：确定数据位流的传输方式，如：单工、半双工或全双工。 物理层协议有： 美国电子工业协会(EIA)的RS232，RS422，RS423，RS485等； 国际电报电话咨询委员会(CCITT)的X.25、X.21等； 物理层的数据单位是位(BIT)，典型设备是集线器HUB。 2、链路层 链路层屏蔽传输介质的物理特征，使数据可靠传送。 内容包括介质访问控制、连接控制、顺序控制、流量控制、差错控制和仲裁协议等。 链路层协议有： 协议有面向字符的通讯协议(PPP)和面向位的通讯协议(HDLC)。 仲裁协议：802.3、802.4、802.5，即： CSMA/CD(Carrier Sense Multiple Access with Collision Detection)、TokenBus、Token Ring 链路层数据单位是帧，实现对MAC地址的访问，典型设备是交换机Switch。 3、网络层 网络层管理连接方式和路由选择。 连接方式：虚电路(Virtual Circuits)和数据报(Datagram)服务。 虚电路是面向连接的(Connection-Oriented)，数据通讯一次路由，通过会话建立的一条通路。 数据报是非连接的(Connectionless-Oriented)，每个数据报都有路由能力。 网络层的数据单位是包，使用的是IP地址，典型设备是路由器Router。 这一层可以进行流量控制，但流量控制更多的是使用第二层或第四层。 4、传输层 提供端到端的服务。可以实现流量控制、负载均衡。 传输层信息包含端口、控制字和校验和。 传输层协议主要是TCP和UDP。 传输层位于OSI的第四层，这层使用的设备是主机本身。 5、会话层 会话层主要内容是通过会话进行身份验证、会话管理和确定通讯方式。 一旦建立连接，会话层的任务就是管理会话。 6、表示层 表示层主要是解释通讯数据的意义，如代码转换、格式变换等，使不同的终端可以表示。 还包括加密与解密、压缩与解压缩等。 7、应用层 应用层应该是直接面向用户的程序或服务，包括系统程序和用户程序， 例如www、FTP、DNS、POP3和SMTP等都是应用层服务。 数据在发送时是数据从应用层至物理层的一个打包的过程， 接收时是数据从物理层至应用层的一个解包的过程， 从功能角度可分为三组，1、2层解决网络信道问题，3、4层解决传输问题，5、6、7层处理对应用进程的访问。 从控制角度可分为二组，第1、2、3层是通信子网层，第4、5、6、7层是主机控制层。 二、TCP/IP 协议簇 TCP/IP(Transmission Control Protocol/Internet Protocol)已成为一个事实上的工业标准。 TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。 TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。 TCP和IP是TCP/IP协议簇的中间两层，是整个协议簇的核心，起到了承上启下的作用。 1、接口层 TCP/IP的最低层是接口层，常见的接口层协议有： Ethernet 802.3、Token Ring 802.5、X.25、Framereley、HDLC、PPP等。 2、网络层 网络层包括：IP(Internet Protocol)协议、ICMP(Internet Control Message Protocol)控制报文协议、ARP(Address Resolution Protocol)地址转换协议、RARP(Reverse ARP)反向地址转换协议。 IP是网络层的核心，通过路由选择将下一跳IP封装后交给接口层。IP数据报是无连接服务。 ICMP是网络层的补充，可以回送报文。用来检测网络是否通畅。 Ping命令就是发送ICMP的echo包，通过回送的echo relay进行网络测试。 ARP是正向地址解析协议，通过已知的IP，寻找对应主机的MAC地址。 RARP是反向地址解析协议，通过MAC地址确定IP地址。比如无盘工作站和DHCP服务。 3、传输层 传输层协议主要是：传输控制协议TCP(Transmission Control Protocol)和用户数据报协议UDP(User Datagram rotocol)。 TCP是面向连接的通信协议，通过三次握手建立连接，通讯时完成时要拆除连接，由于TCP是面向连接的所以只能用于点对点的通讯。 TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出丢包现象，实际应用中要求在程序员编程验证。 4、应用层 应用层一般是面向用户的服务。如FTP、TELNET、DNS、SMTP、POP3。 FTP(File Transmision Protocol)是文件传输协议，一般上传下载用FTP服务，数据端口是20H，控制端口是21H。 Telnet服务是用户远程登录服务，使用23H端口，使用明码传送，保密性差、简单方便。 DNS(Domain Name Service)是域名解析服务，提供域名到IP地址之间的转换。 SMTP(Simple Mail Transfer Protocol)是简单邮件传输协议，用来控制信件的发送、中转。 POP3(Post Office Protocol 3)是邮局协议第3版本，用于接收邮件。 数据格式： 数据帧：帧头＋IP数据包＋帧尾 (帧头包括源和目标主机MAC地址及类型,帧尾是校验字) IP数据包：IP头部＋TCP数据信息 (IP头包括源和目标主机IP地址、类型、生存期等) IP数据信息：TCP头部+实际数据 (TCP头包括源和目标主机端口号、顺序号、确认号、校验字等) 三、TCP连接的建立 1、TCP连接通过三次握手完成。 client首先请求连接，发一个SYN包；Server收到后回应SYN_ACK包；Client收到后再发ACK包。即： Client Server SYN ---&gt; 收 &lt;--- SYN+ACK ACK ---&gt; 收 established表示建立状态，当某端发出数据包后收到了回应则进入established状态。 在TCP/IP连接时，如果两端都是established状态，则握手成功，否则是无连接或半联接状态。 2、套接字Socket 套接字Socket由协议、IP地址和端口号组成，套接字表示一路通讯，一般是一个服务，如www服务是TCP的80端口，Telnet是TCP的23端口。 四、IP地址划分 1、IP地址分类 IP地址有四个段，包括网络标识和主机标识两部分：netid+hostid。 IP地址应用分为A、B、C三类，D、E类是保留和专用的。 Class A 0******* xxxxxxxx xxxxxxxx xxxxxxxx Class B 10****** ******** xxxxxxxx xxxxxxxx Class C 110***** ******** ******** xxxxxxxx Class D 1110**** ******** ******** ******** Class E 1111**** ******** ******** ******** 2、地址区间 址址类 地址区间 网络数 主机数 A 类 1.0.0.1～126.255.255.254 27-2=126 224-2=16777214 B 类 128.0.0.1～191.255.255.254 214-2=16382 216-2=65534 C 类 192.0.0.1～223.255.255.254 221-2=2097150 28-2=254 D 类 224.0.0.1～239.255.255.255 228=268435456 0 E 类 240.0.0.1～255.255.255.255 228=268435456 0 3、特殊地址 主机地址全0表示为一个网络地址。 主机地址全1表示为对应网络的广播地址。 全0的IP地址：0.0.0.0，表示本机地址，只在启动过程时有效。 全1的IP地址255.255.255.255，表示本地广播(有的软件不支持)。 私有地址： 10.0.0.0 - 10.255.255.255 172.16.0.0 - 172.31.255.255 192.168.0.0 - 192.168.255.255 127.0.0.0网络是回环网络loopback，用于本机测试。例如： ping 127.0.0.1 是测试本机网卡是否工作正常。 4、子网掩码 子网掩码用来区分网络地址和主机地址，标准的子网掩码为： A 类： 1.0.0.1～126.255.255.254 netmask：255.0.0.0 B 类：128.0.0.1～191.255.255.254 netmask：255.255.0.0 C 类：192.0.0.1～223.255.255.254 netmask：255.255.255.0 子网掩码和IP地址的“与”运算得出对应的网络地址。 如果将子网掩码“1”的位数增加则网络地址数增加，形成子网。相当于网络的分隔。 如果将子网掩码“1”的位数减小则网络地址数减少，形成超网。相当于网络的聚合。 ##交换机原理与应用一、基本以太网 1、以太网标准： 以太网是Ethernet的意思，过去使用的是十兆标准，现在是百兆到桌面，千兆做干线。 常见的标准有： 10BASE-2 细缆以太网 10BASE-5 粗缆以太网 10BASE-T 星型以太网 100BASE-T 快速以太网 1000BASE-T 千兆以太网 2、接线标准 星型以太网采用双绞线连接，双绞线是8芯，分四组，两芯一组绞在一起，故称双绞线。 8芯双绞线只用其中4芯：1、2、3、6。 常见接线方式有两种： 568B接线规范： 白橙 橙 白绿 蓝 白蓝 绿 白棕 棕 1 2 3 4 5 6 7 8 568A接线规范： 白绿 绿 白橙 蓝 白蓝 橙 白棕 棕 1 2 3 4 5 6 7 8 将568B的1和3对调，2和6对调，就得到568A。 3、接线方法 两边采用相同的接线方式叫做平接，两边采用不同的接线方式叫扭接。 不同的设备之间连接，使用平接线；相同的设备连接使用扭接线。 电脑、路由器与集线器、交换机连接时使用平接线。 这是因为网线中的4条线，一对是输入，一对是输出，输入应该与输出对应。 如果将1和3连接，2和4连接，相当于自己的输出送给自己的输入。 这样可以使网卡进入工作状态，阻止空接口关闭，而影响有些程序的运行。 二、交换机原理与应用 1、冲突域和广播域 交换机是根据网桥的原理发展起来的，学习交换机先认识两个概念： (1)冲突域： 冲突域是数据必然发送到的区域。 HUB是无智能的信号驱动器，有入必出，整个由HUB组成的网络是一个冲突域。 交换机的一个接口下的网络是一个冲突域，所以交换机可以隔离冲突域。 (2)广播域： 广播数据时可以发送到的区域是一个广播域。 交换机和集线器对广播帧是透明的，所以用交换机和HUB组成的网络是一个广播域。 路由器的一个接口下的网络是一个广播域。所以路由器可以隔离广播域。 2、交换机原理 (1)端口地址表 端口地址表记录了端口下包含主机的MAC地址。端口地址表是交换机上电后自动建立的， 保存在RAM中，并且自动维护。 交换机隔离广播域的原理是根据其端口地址表和转发决策决定的。 (2)转发决策 交换机的转发决策有三种操作：丢弃、转发和扩散。 丢弃：当本端口下的主机访问已知本端口下的主机时丢弃。 转发：当某端口下的主机访问已知某端口下的主机时转发。 扩散：当某端口下的主机访问未知端口下的主机时要扩散。 每个操作都要记录下发包端的MAC地址，以备其它主机的访问。 (3)成存期： 生成期是端口地址列表中表项的寿命。每个表项在建立后开始进行倒记时，每次发送 数据都要刷新记时。对于长期不发送数据主机，其MAC地址的表项在生成其结束时删除。 所以端口地地表记录的总是最活动的主机的MAC地址。 3、交换网络中的环 以太网是总线或星型结构，不能构成环路，否则会产两个严重后果： (1)产生广播风暴，造成网络堵塞。 (2)克隆帧会在各个口出现，造成地址学习(记录帧源地址)混乱。 解决环路问题方案: (1)网络在设计时，人为的避免产生环路。 (2)使用生成树STP(Spanning Tree Protocol)功能，将有环的网络剪成无环网络。 STP被IEEE802规范为802.1d标准。 生成树协议术语 (1)网桥协议数据单元：BPDU(Bridge Protocol Data Unit) BPDU是生成树协议交换机间通讯的数据单元，用于确定角色。 (2)网桥号：Bridge ID 交换机的标识号，它由优先级和MAC地址组成，优先级16位，MAC地址48位。 (3)根网桥：Root bridge 根网桥定义为网桥号最小的交换机，根网桥所有的端口都不会阻塞。 (4)根端口：Root port 非根网桥到根网桥累计路径花费最小的端口，负责本网桥与根网桥通讯的接口。 (5)指定网桥：Designated bridge 网络中到根网桥累计路径花费最小交换机，负责收发本网段数据。 (6)指定端口：Designated port 网络中到根网桥累计路径花费最小的交换机端口，根网桥每个端口都是指定端口。 (7)非指定端口：NonDesignated port 余下的端口是非指定端口，它们不参与数据的转发，也就是被阻塞的端口。 (根端口是从非根网桥选出，指定端口是网段中选出)。 生成树协议的状态： 生成树协议工作时，所有端口都要经过一个端口状态的建立过程。 生成树协议通过BPDU广播，确定各交换机及其端口的工作状态和角色， 交换机上的端口状态分别为：关闭、阻塞、侦听、学习和转发状态。 (1)关闭状态：Disabled 不收发任何报文，当接口空连接或人为关闭时处于关闭状态。 (2)阻塞状态：Blocking 在机器刚启动时，端口是阻塞状态(20秒)，但接收BPDU信息。 (3)侦听状态：listening 不接收用户数据(15秒)，收发BPDU，确定网桥及接口角色。 (4)学习状态：learning 不接收用户数据(15秒)，收发BPDU，进行地址学习。 (5)转发状态：Forwarding 开始收发用户数据，继续收发BPDU和地址学习,维护STP。 4、关于VLAN VLAN(Virtual Lan)是虚拟逻辑网络，交换机通过VLAN设置，可以划分为多个逻辑网络， 从而隔离广播域。具有三层模块的交换机可以实现VLAN间的路由。 (1)端口模式 交换机端口有两种模式，access和trunk。access口用于与计算机相连，而交换机之间 的连接，应该是trunk。 交换机端口默认VLAN是VLAN1，工作在access模式。 Access口收发数据时，不含VLAN标识。具有相同VLAN号的端口在同一个广播域中。 Trunk口收发数据时，包含VLAN标识。Trunk又称为干线，可以设置允许多个VLAN通过。 (2)VLAN中继协议： VLAN中继协议有两种： ISL(Inter-Switch Link)： ISL是Cisco专用的VLAN中继协议。 802.1q(dot1q)：802.1q是标准化的，应用较为普遍。 (3)VTP VTP(Vlan Trunking Protocol)是VLAN传输协议，在含有多个交换机的网络中，可以 将中心交换机的VLAN信息发送到下级的交换机中。 中心交换机设置为VTP Server，下级交换机设置为VTP Client。 VTP Client要能学习到VTP Server的VLAN信息，要求在同一个VTP域，并要口令相同。 (4)VLAN共享 如果要求某个VLAN与其他VLAN访问，可以设置VLAN共享或主附VLAN。 共享模式的VLAN端口，可以成为多个VLAN的成员或同时属于多个VLAN。 在主附VLAN结构中，子VLAN与主VLAN可以相互访问，子VLAN间的端口不能互相访问。 一般的VLAN间使用不同网络地址；主附VLAN中主VLAN和子VLAN使用同一个网络地址。 5、交换机和路由器的口令恢复: (1)交换机的口令恢复: 交换机的口令恢复的操作是先启动超级终端，在交换机上电时按住的mode键. 几秒后松手，进入ROM状态，将nvram中的配置文件config.txt改名或删除，再重启。 参考命令为： switch:rename flash:config.text flash:config.bak switch:erase flash:config.text (2)路由器的口令恢复: 路由器的口令恢复操作先启动超级终端，在路由器上电时按计算机的Ctrl+Break键， 进入ROM监控状态rommon&gt;，用配置寄存器命令confreg设置参数值0x2142，跳过配置文件 设置口令后再还原为0x2102。 参考命令为： rommon&gt;confreg 0x2142 router(config)#config-register 0x2102 没有特权口令无法进入特权状态，只能进入ROM监控状态，使用confreg 0x2142命令。 当口令修改完后，可以在特权模式下恢复为使用配置文件状态。 三、三层交换的概念 1、交换机是链路层设备，使用MAC地址，完成对帧的操作。 交换机的IP地址做管理用，交换机的IP地址实际是VALN的IP。 一个VLAN一个广播域，不同VLAN的主机间访问，相当于网络间的访问，要通过路由实现。 不同VLAN间主机的访问有以下几种情况： (1)两个VLAN分别接入路由器的两个物理接口。这是路由器的基本应用。 (2)两个VLAN通过trunk接入路由器的一个物理接口，这是应用于子接口的单臂路由。 (3)使用具有三层交换模块的交换机。Cisco的3550和华为的3526都是基本的三层交换机。 1)通过VLAN的IP地址做网关，实现三层交换，要求设置VLAN的IP地址。 2)将端口设置在三层工作，要求端口设置no switchport，再设置端口的IP地址。 2、交换机的通道技术 交换机通道技术是将交换机的几个端口捆绑使用，即端口的聚合。 使用通道技术一个方面提高了带宽，同时提高了线路的可靠性。 但是如果设置不当，有可能产生环路，造成广播风暴堵塞网络。 要聚合的端口要划分到指定的VLAN或trunk。 配置三层通道时，先要进入通道，再用no switchport命令关闭二层，设置通道IP地址。 一个通道一般小于8个接口，接口参数应该一致，如工作模式、封装的协议、端口类型。 3、端口协商方式 端口的聚合有两种方式，一种是手动的方式，一个是自动协商的方式。 手动的方式很简单，设置端口成员链路两端的模式为“on”。命令格式为： channel-group mode on 自动方式有两种类型： PAgP(Port Aggregation Protocol)和LACP(Link aggregation Control Protocol)。 PAgP：Cisco设备的端口聚合协议，有auto和desirable两种模式。 auto模式在协商中只收不发，desirable模式的端口收发协商的数据包。 LACP：标准的端口聚合协议802.3ad，有active和passive两种模式。 active相当于PAgP的auto，而passive相当于PAgP的desirable。 4、通道端口间的负载平衡 通道端口间的负载平衡有两种方式，基于源MAC的转发和基于目的MAC的转发。 scr-mac：源MAC地址相同的数据帧使用同一个端口转发。 dst-mac：目的MAC地址相同的数据帧使用同一个端口转发。 ##路由器原理与应用一、路由的基本概念 路由器的网络层的设备，负责IP数据包的路由选择和转发。 1、路由类型 路由的类型有：直连路由、静态路由、默认路由和动态路由。 直连路由是与路由器直接相联网络的路由，路由器有对直连网络有转发能力。 静态路由是管理员人为设置的路由，网络开支小，可以有效的改善网络状况。 默认路由是静态路由的一个特例，将路由表不能匹配的数据包送默认路由。一般在最后。 动态路由是路由协议自动建立和管理的路由，常见动态路由协议有： RIP(Routing Information Protocol) 、 IGRP(Interior Gateway Routing Protocol)、 EIGRP(Enhance Interior Gateway Routing Protocol)、 OSPF(Open Shortest Path First)、 BGP(Backbone Getway Protocol) 上述路由协议称为routing protocol，而IP、IPX称为可路由的协议routed protocol。 也有一些协议是不可路由的，如NetBEUI协议。 2、路由算法 路由算法常见的有三种类型： 距离矢量D-V(Distance-Vector) 算法，如：RIP、IGRP、BGP； 链路状态L-S(Link State)算法，如：OSPF、IS-IS； 混合算法，如：Cisco的EIGRP。 3、路由交换范围 路由器通过交换信息建立路由表，当网络结构变化时，路由表能自动维护。 路由表跟随网络结构变化过程称为收俭。为了减少收俭过程引起的网络动荡，要考滤 路由交换范围。 RIP协议通过network命令指定，例如：设置10.0.0.0网络的接口参与路由信息交换 router(config-router)network 10.0.0.0 ospf协议通过network命令指定，例如：设置10.65.1.1 接口参与路由交换 router(config-router)network 10.65.1.1 0.0.0.0 area 0 area是网络管理员在自治系统(国际机构分配)AS(Autonomous System)内部划分的区域。 0.0.0.0是匹配码，0表示要求匹配，1表示不关心。 4、路由表 路由表(Routing Table)是路由器中路由项的集合，是路由器进行路径选择的依据， 每条路由项包括：目的网络和下一跳，还有优先级，花费等。 路由优先匹配原则： (1)直接路由：直连的网络优先级最高。 (2)静态路由：优先级可设，一般高于动态路由。 (3)动态路由：相同花费时，长掩码的子网优先。 (4)默认路由：最后有一条默认路由，否则数据包丢弃。 二、RIP路由协议 1、RIP协议的认识 RIP(Routing Information Protocol)协议是采用D-V(Distance-Vector)算法的距离矢量协议； 根据跳数(Hop Count)来决定最佳路径。最大跳数为16，限制了网络的范围。 单独以跳数作为距离或花费，在有些情况下是不合理的，因为跳数少不一定是最佳路径； 实际上带宽和可靠性也是重要的因素。有时需要管理员修改花费值。 RIP有两个版本，RIP-1 和RIP-2。 RIP-1：采用广播方式发送报文。不支持子网路由。 RIP-2：支持多播方式、子网路由和路由的聚合。 2、路由表的维护 通过UDP协议每隔30秒发送路由交换信息，从而确定邻居的存在。 若180秒还没有收到某相邻结点路由信息，标记为此路不可达。 若再120秒后还没有收到路由信息，则删除该条路由。 当网络结构变化时，要更新路由表，这个过程称为收敛(Convergence)。 RIP标记一条路由不可达要经过3分钟，收敛过程较慢。 路由表是在内存当中的，路由器上电时初始化路由表，对每个直接网络生成一条路由。 同时复制相邻路由器的路由表，复制过程中跳数加1，且下一跳指向该路由器。 若去往某网络的下一跳是RouteA，若RouteA去该网络的路由没有了，则删除这一路由。 跳数是到达目的网络所经过的路由器数目，直接网络的跳数是0，且有最高的优先级。 3、路由环路： 矢量路由的一个弱点就是可能产生路由环路，产生路由环路的原因有两种， 一是静态路由设置的不合理，再一是动态路由定时广播产生的误会。 先看静态路由设置不合理的情况： 设两个路由器RouterA和RouterB，其路由表中各有一条去往相同目的网络的静态路由， 但下一跳彼此指向对方，形成环路。 再看动态路由造成的情况： 假设某路由器RouterA通过RouterB至网络neta， 但RouteB到neta不可达了，且RouterB的广播路由比RouterA先来到， RouterB去neta不可达，但RouterA中有去往neta路由，且下一跳是RouterB， 这时RouteB就会从RouterA那里学习该路由，将去往neta的指向RouterA，跳数加1。 去neta的路由原本是RouterB传给RouterA的，现RouterB却从RouterA学习该路由， 显然是不对的，但这一现象还会继续， RouterA去neta网络的下一路是RouterB，当RouterB的跳数加1的时候，RouterA将再加1。 周而复反形成环路，直至路由达到最大值16。 4、解决路由环路的办法 (1) 规定最大跳数 RIP规定了最大跳数为16，跳数等于16时视为不可达，从而阻止环跳进行。 (2) 水平分割 水平分割是过滤掉发送给原发者的路由信息。具体路由信息单向传送。 (3) 毒性逆转 水平分割的改进，收到原是自己发出的路由信息时，将这条信息跳数置成16，即毒化。 (4) 触发方式 一旦发现网络变化，不等呼叫，立即发送更新信息，迅速通知相邻路由器，防止误传。 (5) 抑制时间 在收到路由变化信息后，启动抑制时间，此时间内变化项被冻结，防止被错误地覆盖。 三、OSPF路由协议 1、OSPF的特点 OSPF(Open Shortest Path First)开放式最短路径优先协议， 使用L-S(Link State)算法的链路状态路由协议，路由算法复杂，适合大型网络， 网络拓扑结构变化时，采用触发方式，组播更新，收敛快，要求更高的内存和CPU资源。 LSA(Link State Advertisement)链路状态通告是以本路由器为根的最小路径优先树。 LSDB(Link State DataBase)链路状态数据库，这是各个路由器的LSA的集合。 每个路由器的LSA是不同的，但他们的集合LSDB是相同的。 D-V算法只考虑下一跳，没有全局的概念，交给下一跳就完成任务，所以容易产生环路。 L-S算法每个路由器可以根据网络整体结构决定路径，所以不会产生环。 2、指定路由器与路由器标识 指定路由器DR(Dezignated Router)是ospf路由交换的中心，数据通过DR进行交换。 在路由器群组中优先级(Router Priority)值最高的为DR，次高的为备份指定路由器BDR。 管理员可以通过设置优先级指定DB和BDR。优先级相同时，比较 router id。 如果没有设置Router id，则以回环接口loopback ip值高的为DR， 如果loopback ip 没有设置，取接口的IP地址中最高的为DR。 3、建立路由表 (1)Hello报文 Hello报文用于发现新邻居问候老邻居，选举指定路由器DR和BDR。 (2)DD报文(Database Description Packet) DD报文用LSA头head信息表示LSA的变化情况，将其发送给DR，DR再发给其它路由器。 (3)LSR报文(Link State Request Packet) LSR是请求更新包，当LSDB需要更新时，将其发送给DR，点对点连接时直接同步LSDB。 (4)LSU报文(Link State Update Packet) DR用多播Multicast地址224.0.0.6收，224.0.0.5发，同步整个区域的LSDB。 (5)确认后计算路由： LSDB同步后，计算cost花费，考虑跳数、带宽、可靠性等综合因素求解最佳路径。 4、单区域OSPF配置 单区域OSPF配置是指运行OSPF协议的路由器在同一个区域area n， 对于只有一个区域的网络，区域号是任意的，一般设置为0。 单区域OSPF有三种连接情况： 点对点的连接(Point to point)、 广播方式的连接(Broadcast Multi Access Network)、 非广播方式多点连接(Non Multi Access Network)。 点对点连接结构最简单，可靠性高，工作稳定； 以太网连接是典型的广播方式的连接； 帧中继连接是属于的非广播方式多点连接类型。 5、多区域OSPF的设置 多区域中要求有一个是骨干区域area 0，边界路由器跨接两个区域。 多区域的区域内部按单区域设置，多区域间通过边界路由器的连接。 stub是末节区域，末节区域不接收ospf以外的路由信息， 如果路由器想去往区域以外网络，要使用默认路由。 只有多区域中才存在末节区域。末节区域要设置在边界路由器上。 作为企业可以将分支区域设置为末节区域， 分支区域不需要知道总部网络的细节，却能够通过缺省路由到达那里。 四、访问控制列表 1、访问控制列表类型与作用 访问控制列表是对通过路由器的数据包进行过滤。 过滤是根据IP数据包的5个要素： 源IP地址、目的IP地址、协议号、源端口、目的进行的。 访问控制列表有两类，标准访问控制例表和扩展的访问控制列表。 标准访问列表： 标准访问列表的列表号为1~99，只对源IP地址进行访问控制。 扩展访问列表： 扩展访问列表的列表号为100~199，可以对源和目的地址、协议、端口号进行访问控制。 2、访问控制列表的结构 分三步： 定义一个ACL：access-list 进入指定接口：interface 绑定指定ACL：ip access-group [in|out] 3、访问控制列表匹配原则 访问控制列表默认的是deny any。 一般是逐行匹配，也可以设置深度匹配。 所以写访问控制列表一般是从小的范围向大的范围，成为梯形结构。 一般在访问控制表的最后一行要写permit any。 4、命名方式的访问控制列表 命名方式是用名称代替列表号，便于记忆，扩展了条目数量，可以是基本型或扩展型。 命令方式ACL语法有些变化，支持删除一个列表中的某个语句。 命名语法格式： router(config)#ip access-list {standard|extended} name router(config std nacl)#{deny|permit}] router(config ext nacl)#{deny|permit}[protocol][op] 第一行是定义命名方式访问控制列表类型：标准或扩展。 第二行是标准命名方式的访问控制列表的语法格式。 第三行是扩展命令方式的访问控制列表的语法格式。 五、地址转换NAT 1、NAT的认识 NAT(Network Address Translate)是地址转换操作。 NAT可以将局网中的私有IP转换成公有IP，解决了内部网络访问internet的问题。 NAT可以做负载均衡，将内部多个服务器对外映射成一台服务器。 定义： Inside local address: 内部网的私有IP。 Inside global address: 内部网的公有IP。 Outside global address: 互联网中的公有IP。 Outside local address: 互联网中的公有IP对应的私有IP。 NAT可分为原地址变换SNAT和目的地址变换DNAT。 按工作方式划分，可分为静态NAT和动态NAT。 SNAT命令中使用source参数，DNAT命令中使用destination参数。 (对已连接的返回包可自动对应) 2、静态NAT 静态NAT是在指定接口上，对数据包的原IP或目的IP进行一对一的转换。 常用于将某个私有IP固定的映射成为一个公有IP。 语法： Router(config)#ip nat inside source static 在指定接口inside中对数据包的原地址进行变换，一般ipa是私网IP，ipb是公网IP。 3、动态NAT 动态NAT一般用于将局域网中的多个私有IP从公有IP地址池中提取公有IP对外访问。 设内部局域网是：10.66.0.0，公网IP地址池为：60.1.1.1~60.1.1.8 当内部网络要访问internet时，从公网IP地址池中提取公网IP对外访问。 语法： 定义地址池p1： Router(config)#ip nat pool p1 60.1.1.1 60.1.1.8 netmask 255.255.255.0 定义访问控制列表1： Router(config)#access-list 1 permit 10.66.0.0 0.0.255.255 将访问控制列表1的源地址，动态的从公网IP地址池p1的提取公网IP: Router(config)#ip nat inside source list 1 pool p1 4、PAT PAT(Port Address Translate)是端口地址转换，将私有IP转换到公网IP的不同端口上。 PAT是原将动态nat地址池pool改为用接口，并使用参数overload。属于动态NAT。 语法： Router(config)#access-list 2 permit 10.66.0.0 0.0.255.255 Router(config)#ip nat inside source list 2 interface s0/0 overload 5、基于NAT的负载均衡 NAT可以实现负载均衡。 一般的NAT都是将内部私有IP转换为公网IP，连接方向从内部向外。 而对于负载均衡是将一个公网IP翻译成多个内部私有IP，连接访问从外向内。 例如： 内部的www服务负载过重，可将多台同样的服务器，但对外映射成一个IP地址， 内部的多台服务器成为捆绑在一起构成虚拟服务器，外部访问这个虚拟服务器时， 路由器轮流指向各台服务器，从而达到负载均衡。 语法： 定义地址池p2，使用rotary参数轮循。 ra(config)#ip nat pool p2 10.1.1.2 10.1.1.4 netmask 255.255.255.0 type rotary ra(config)#access-list 1 permit 60.1.1.1 ra(config)#ip nat inside destination list 1 pool p2 在指定接口inside中建立list 2与pool p2的对应关系。Destination表示转换目的地址。 6、基于服务的NAT 基于服务的NAT配置，细化了NAT的应用，转换可以具体到协议和端口，即指定的服务上。 例如: 对内网的虚拟服务器(使用一个公网IP)的访问： 当访问TCP 20端口时就将它转到内部ftp服务上。 当访问TCP 21端口时也将它转到内部ftp服务上。 当访问TCP 80端口时就将它转换到内部的www服务器上。 语法： Router(config)#ip nat inside source static tcp 10.65.1.2 20 60.1.1.1 20 Router(config)#ip nat inside source static tcp 10.65.1.2 21 60.1.1.1 21 Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80 ##常见广域网协议及特点一、常用的广域网协议 PPP(Point to Point Protocol)、HDLC(High level Data Link Control)、fram-relay。 PPP：点对点的协议，华为路由器默认封装，是面向字符的控制协议。 HDLC：高级数据链路控制协议，Cisco路由器默认的封装，是面向位的控制协议。 fram-relay：表示帧中继交换网，它是x.25分组交换网的改进，以虚电路的方式工作。 二、PPP协议 1、PPP协议的组成和特点 PPP协议是在SLIP基础上开发的，解决了动态IP和差错检验问题。 PPP协议包含数据链路控制协议LCP和网络控制协议NCP。 LCP协议提供了通信双方进行参数协商的手段。 NCP协议使PPP可以支持IP、IPX等多种网络层协议及IP地址的自动分配。 PPP协议支持两种验证方式：PAP和CHAP。 2、PAP(Password Authentication Protocol)验证 PAP验证是简单认证方式，采用明文传输，验证只在开始联接时进行。 验证方式： (1)被验方先发起联接，将username和Password一起发给主验方。 (2)主验方收到被验方username和Password后，在数据库中进行匹配，并回送ACK或NAK。 3、CHAP(Challenge-Handshake Authentication Protocol)验证 CHAP是要求握手验证方式，安全性较高，采用密文传送用户名。 主验方和被验方两边都有数据库。 要求双方的用户名互为对方的主机名，即本端的用户名等于对端的主机名，且口令相同。 验证方式： (1) 主验方向被验证方发送随机报文，将自己的主机名一起发送。 (2) 被验方根据主验方的主机名在本端的用户表中查找口令字， 将口令加密运算后加上自己的主机名及用户名回送主验方。 (3) 主验方根据收到的被验方的用户名在本端查找口令字，根据验证结果返回验证结果。 三、HDLC协议 HDLC(High level Data Link Control)高级数据链路层控制协议。是Cisco的路由器 默认的封装协议。 HDLC是面向位协议，用”数据位”定义字段类型，而不用控制字符，通过帧中用”位”的组 合进行管理和控制。 帧格式为： 字段：开始标志 地址字段 控制字段 信息字段 校验序列 结束标志 位长： 8 8*n 8 任意 16 8 字段：F=01111110 A C I FCS F=01111110 四、帧中继 企业网申请帧中继时，局端提供DLCI号和接入的LMI类型，局端是DCE，客户端是DTE。 设局端提供的虚电路号DLCI是16和17，本地管理类型接口LMI是Cisco。 设置内容：连接端口的IP地址，指定lmi类型，设置虚电路号。 例如： Router(config)#int s0/0 Router(config-if)#ip address 172.l6.20.1 255.255.255.0 Router(config-if)#encap frame-relay Router(config-if)#frame-relay lmi-type cisco Router(config-if)#frame-relay dlci 16 如果在实验室条件下配置帧中继，要求用一个路由器做继交换机switching。 Router(config)#frame-relay switching 当要求一点对多点时，可以使用子接口的帧中继设置。 ##PIX防火墙特点与应用一、PIX防火墙的认识 PIX是Cisco的硬件防火墙，硬件防火墙有工作速度快，使用方便等特点。 PIX有很多型号，并发连接数是PIX防火墙的重要参数。PIX25是典型的设备。 PIX防火墙常见接口有：console、Failover、Ethernet、USB。 网络区域： 内部网络：inside 外部网络：outside 中间区域：称DMZ (停火区)。放置对外开放的服务器。 二、防火墙的配置规则 没有连接的状态(没有握手或握手不成功或非法的数据包)，任何数据包无法穿过防火墙。 (内部发起的连接可以回包。通过ACL开放的服务器允许外部发起连接) inside可以访问任何outside和dmz区域。 dmz可以访问outside区域。 inside访问dmz需要配合static(静态地址转换)。 outside访问dmz需要配合acl(访问控制列表)。 三、PIX防火墙的配置模式： PIX防火墙的配置模式与路由器类似，有4种管理模式： PIXfirewall&gt;：用户模式 PIXfirewall#：特权模式 PIXfirewall(config)#：配置模式 monitor&gt;：ROM监视模式，开机按住[Esc]键或发送一个“Break”字符，进入监视模式。 四、PIX基本配置命令 常用命令有：nameif、interface、ip address、nat、global、route、static等。 1、nameif 设置接口名称，并指定安全级别，安全级别取值范围为1～100，数字越大安全级别越高。 例如要求设置： ethernet0命名为外部接口outside，安全级别是0。 ethernet1命名为内部接口inside，安全级别是100。 ethernet2命名为中间接口dmz, 安装级别为50。 使用命令： PIX525(config)#nameif ethernet0 outside security0 PIX525(config)#nameif ethernet1 inside security100 PIX525(config)#nameif ethernet2 dmz security50 2、interface 配置以太口工作状态，常见状态有：auto、100full、shutdown。 auto：设置网卡工作在自适应状态。 100full：设置网卡工作在100Mbit/s，全双工状态。 shutdown：设置网卡接口关闭，否则为激活。 命令： PIX525(config)#interface ethernet0 auto PIX525(config)#interface ethernet1 100full PIX525(config)#interface ethernet1 100full shutdown 3、ip address 配置网络接口的IP地址，例如： PIX525(config)#ip address outside 133.0.0.1 255.255.255.252 PIX525(config)#ip address inside 192.168.0.1 255.255.255.0 内网inside接口使用私有地址192.168.0.1，外网outside接口使用公网地址133.0.0.1。 4、global 指定公网地址范围：定义地址池。 Global命令的配置语法： global (if_name) nat_id ip_address-ip_address [netmark global_mask] 其中： (if_name)：表示外网接口名称，一般为outside。 nat_id：建立的地址池标识(nat要引用)。 ip_address-ip_address：表示一段ip地址范围。 [netmark global_mask]：表示全局ip地址的网络掩码。 例如： PIX525(config)#global (outside) 1 133.0.0.1-133.0.0.15 地址池1对应的IP是：133.0.0.1-133.0.0.15 PIX525(config)#global (outside) 1 133.0.0.1 地址池1只有一个IP地址 133.0.0.1。 PIX525(config)#no global (outside) 1 133.0.0.1 表示删除这个全局表项。 5、nat 地址转换命令，将内网的私有ip转换为外网公网ip。 nat命令配置语法：nat (if_name) nat_id local_ip [netmark] 其中： (if_name)：表示接口名称，一般为inside. nat_id： 表示地址池，由global命令定义。 local_ip： 表示内网的ip地址。对于0.0.0.0表示内网所有主机。 [netmark]：表示内网ip地址的子网掩码。 在实际配置中nat命令总是与global命令配合使用。 一个指定外部网络，一个指定内部网络，通过net_id联系在一起。 例如： PIX525(config)#nat (inside) 1 0 0 表示内网的所有主机(0 0)都可以访问由global指定的外网。 PIX525(config)#nat (inside) 1 172.16.5.0 255.255.0.0 表示只有172.16.5.0/16网段的主机可以访问global指定的外网。 6、route route命令定义静态路由。 语法： route (if_name) 0 0 gateway_ip [metric] 其中： (if_name)：表示接口名称。 0 0 ：表示所有主机 Gateway_ip：表示网关路由器的ip地址或下一跳。 [metric]：路由花费。缺省值是1。 例如： PIX525(config)#route outside 0 0 133.0.0.1 1 设置缺省路由从outside口送出，下一跳是133.0.0.1。 0 0 代表 0.0.0.0 0.0.0.0，表示任意网络。 PIX525(config)#route inside 10.1.0.0 255.255.0.0 10.8.0.1 1 设置到10.1.0.0网络下一跳是10.8.0.1。最后的“1”是花费。 7、static 配置静态IP地址翻译，使内部地址与外部地址一一对应。 语法： static(internal_if_name,external_if_name) outside_ipaddr inside ip_address 其中： internal_if_name表示内部网络接口，安全级别较高，如inside。 external_if_name表示外部网络接口，安全级别较低，如outside。 outside_ipaddress表示外部网络的公有ip地址。 inside ip_address表示内部网络的本地ip地址。 (括号内序顺是先内后外，外边的顺序是先外后内) 例如： PIX525(config)#static (inside，outside) 133.0.0.1 192.168.0.8 表示内部ip地址192.168.0.8，访问外部时被翻译成133.0.0.1全局地址。 PIX525(config)#static (dmz，outside) 133.0.0.1 172.16.0.2 中间区域ip地址172.16.0.2，访问外部时被翻译成133.0.0.1全局地址。 8、conduit 管道conduit命令用来设置允许数据从低安全级别的接口流向具有较高安全级别的接口。 例如允许从outside到DMZ或inside方向的会话(作用同访问控制列表)。 语法： conduit permit|deny protocol global_ip port[-port] foreign_ip [netmask] 其中： global_ip是一台主机时前面加host参数，所有主机时用any表示。 foreign_ip 表示外部ip。 [netmask] 表示可以是一台主机或一个网络。 例如： PIX525(config)#static (inside，outside) 133.0.0.1 192.168.0.3 PIX525(config)#conduit permit tcp host 133.0.0.1 eq www any 这个例子说明static和conduit的关系。192.168.0.3是内网一台web服务器， 现在希望外网的用户能够通过PIX防火墙访问web服务。 所以先做static静态映射：192.168.0.3－&gt;133.0.0.1 然后利用conduit命令允许任何外部主机对全局地址133.0.0.1进行http访问。 9、访问控制列表ACL 访问控制列表的命令与couduit命令类似， 例： PIX525(config)#access-list 100 permit ip any host 133.0.0.1 eq www PIX525(config)#access-list 100 deny ip any any PIX525(config)#access-group 100 in interface outside 10、侦听命令fixup 作用是启用或禁止一个服务或协议， 通过指定端口设置PIX防火墙要侦听listen服务的端口。 例： PIX525(config)#fixup protocol ftp 21 启用ftp协议，并指定ftp的端口号为21 PIX525(config)#fixup protocol http 8080 PIX525(config)#no fixup protocol http 80 启用http协议8080端口，禁止80端口。 11、telnet 当从外部接口要telnet到PIX防火墙时，telnet数据流需要用vpn隧道ipsec提供保护或 在PIX上配置SSH，然后用SSH client从外部到PIX防火墙。 例： telnet local_ip [netmask] local_ip 表示被授权可以通过telnet访问到PIX的ip地址。 如果不设此项，PIX的配置方式只能用console口接超级终端进行。 12、显示命令： show interface ；查看端口状态。 show static ；查看静态地址映射。 show ip ；查看接口ip地址。 show config ；查看配置信息。 show run ；显示当前配置信息。 write terminal ；将当前配置信息写到终端。 show cpu usage ；显示CPU利用率，排查故障时常用。 show traffic ；查看流量。 show connect count ；查看连接数。 show blocks ；显示拦截的数据包。 show mem ；显示内存 13、DHCP 服务 PIX具有DHCP服务功能。 例： PIX525(config)#ip address dhcp PIX525(config)#dhcpd address 192.168.1.100-192.168.1.200 inside PIX525(config)#dhcp dns 202.96.128.68 202.96.144.47 PIX525(config)#dhcp domain abc.com.cn 五、PIX防火墙举例 设： ethernet0命名为外部接口outside，安全级别是0。 ethernet1被命名为内部接口inside，安全级别100。 ethernet2被命名为中间接口dmz，安全级别50。 PIX525#conf tPIX525(config)#nameif ethernet0 outside security0PIX525(config)#nameif ethernet1 inside security100PIX525(config)#nameif ethernet2 dmz security50PIX525(config)#interface ethernet0 autoPIX525(config)#interface ethernet1 100fullPIX525(config)#interface ethernet2 100fullPIX525(config)#ip address outside 133.0.0.1 255.255.255.252 ;设置接口IPPIX525(config)#ip address inside 10.66.1.200 255.255.0.0 ;设置接口IPPIX525(config)#ip address dmz 10.65.1.200 255.255.0.0 ;设置接口IPPIX525(config)#global (outside) 1 133.1.0.1-133.1.0.14 ;定义的地址池PIX525(config)#nat (inside) 1 0 0 ;0 0表示所有 PIX525(config)#route outside 0 0 133.0.0.2 ;设置默认路由PIX525(config)#static (dmz，outside) 133.1.0.1 10.65.1.101 ;静态NATPIX525(config)#static (dmz，outside) 133.1.0.2 10.65.1.102 ;静态NATPIX525(config)#static (inside，dmz) 10.66.1.200 10.66.1.200 ;静态NATPIX525(config)#access-list 101 permit ip any host 133.1.0.1 eq www;设置ACLPIX525(config)#access-list 101 permit ip any host 133.1.0.2 eq ftp;设置ACLPIX525(config)#access-list 101 deny ip any any ;设置ACLPIX525(config)#access-group 101 in interface outside ;将ACL应用在outside端口 当内部主机访问外部主机时，通过nat转换成公网IP，访问internet。 当内部主机访问中间区域dmz时，将自己映射成自己访问服务器，否则内部主机将会 映射成地址池的IP，到外部去找。 当外部主机访问中间区域dmz时，对133.0.0.1映射成10.65.1.101， static是双向的。 PIX的所有端口默认是关闭的，进入PIX要经过acl入口过滤。 静态路由指示内部的主机和dmz的数据包从outside口出去。 ##PIX 防火墙应用举例设： ethernet0命名为外部接口outside，安全级别是0。 ethernet1被命名为内部接口inside，安全级别100。 ethernet2被命名为中间接口dmz，安全级别50。 参考配置：PIX525#conf t ;进入配置模式PIX525(config)#nameif ethernet0 outside security0 ;设置定全级0PIX525(config)#nameif ethernet1 inside security100 ;设置定全级100PIX525(config)#nameif ethernet2 dmz security50 ;设置定全级50PIX525(config)#interface ethernet0 auto ;设置自动方式PIX525(config)#interface ethernet1 100full ;设置全双工方式PIX525(config)#interface ethernet2 100full ;设置全双工方式PIX525(config)#ip address outside 133.0.0.1 255.255.255.252 ;设置接口IPPIX525(config)#ip address inside 10.66.1.200 255.255.0.0 ;设置接口IPPIX525(config)#ip address dmz 10.65.1.200 255.255.0.0 ;设置接口IPPIX525(config)#global (outside) 1 133.1.0.1-133.1.0.14 ;定义的地址池PIX525(config)#nat (inside) 1 0 0 ;0 0表示所有 PIX525(config)#route outside 0 0 133.0.0.2 ;设置默认路由PIX525(config)#static (dmz，outside) 133.1.0.1 10.65.1.101 ;静态NATPIX525(config)#static (dmz，outside) 133.1.0.2 10.65.1.102 ;静态NATPIX525(config)#static (inside，dmz) 10.66.1.200 10.66.1.200 ;静态NATPIX525(config)#access-list 101 permit ip any host 133.1.0.1 eq www;设置ACLPIX525(config)#access-list 101 permit ip any host 133.1.0.2 eq ftp;设置ACLPIX525(config)#access-list 101 deny ip any any ;设置ACLPIX525(config)#access-group 101 in interface outside ;将ACL应用在outside端口 当内部主机访问外部主机时，通过nat转换成公网IP，访问internet。 当内部主机访问中间区域dmz时，将自己映射成自己访问服务器，否则内部主机将会 映射成地址池的IP，到外部去找。 当外部主机访问中间区域dmz时，对133.0.0.1映射成10.65.1.101， static是双向的。 PIX的所有端口默认是关闭的，进入PIX要经过acl入口过滤。 静态路由指示内部的主机和dmz的数据包从outside口出去。","excerpt":"目录 基本实验 实验一 计算机和交换机基本设置 实验二 配置端口聚合 实验三 基本VLAN设置 实验四 配置primary VLAN和secondary VLAN 实验五 交换机的镜像与生成树 实验六 路由器BootROM升级 实验七 直联路由 实验八 单臂路由 实验九 静态路由实验 实验十 动态路由实验 实验十一 访问控制列表实验 实验十二 地址转换配置","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"GUN/Linux编程|学习笔记","date":"2017-04-27T04:46:30.000Z","path":"2017/04/27/GUN-Linux编程[学习笔记]/","text":"本文为《GUN/Linux编程》的个人读书笔记 &lt;未完待续&gt; 目录： 1UNIX系统概述 1.1UNIX的发展历史 1.1.1UNIX的产生与发展 1.1.2UNIX的相关标准 1.2GNU的诞生与发展 1.2.1自由软件计划GNU 1.2.2许可证协议 1.2.3自由软件和开源软件 1.3Linux 内核 1.3.1Minix操作系统 1.3.2Linux的产生与发展 1.3.3Linux内核版本 1.3.4Linux内核的分类 1.4Linux 系统 1.4.1Linux系统的概念 1.4.2GNU/Linux 1.4.3Linux 发行版 1.5Linux系统的商业运营模式 2Shell命令 2.1Shell命令概述 2.1.1目录的组织结构 2.1.2文件的路径 2.1.3Linux命令的语法结构 2.1.4Shell命令的分类 2.1.5联机帮助 2.2目录和文件操作 2.2.1目录操作 2.2.2文件操作 2.2.3显示文本文件内容 2.2.4硬链接和软链接 2.3用户和用户组管理 2.3.1用户的分类 2.3.2用户组管理 2.3.3用户管理 2.3.4用户属性的修改 2.3.5用户管理相关配置文件 2.4文件的权限管理 2.4.1文件属性 2.4.2权限的修改 2.4.3权限验证 2.4.4权限掩码umask 2.4.5文件和目录权限的计算 2.5进程管理 2.5.1进程的管理信息 2.5.2与进程相关的命令 2.6Linux的备份与恢复 2.6.1面向文件的备份与恢复 2.6.2面向文件系统的备份 2.6.3面向设备的备份与恢复 2.7Linux应用软件包管理 2.7.1应用软件包的分类 2.7.2RPM软件包的管理 2.8输入输出重定向和管道 2.8.1标准输入输出文件的定义 2.8.2输人输出重定向 2.8.3管道 2.9元字符与正则表达式 2.9.1元字符 2.9.2正则表达式 3Linux系统的定制 3.1磁盘管理 3.1.1硬盘的物理结构 3.1.2磁盘分区 3.1.3分区格式化 3.1.4 ext2文件系统 3.1.5文件系统的挂载与卸载 3.2引导加载程序grub 3.2.1引导加载的概念 3.2.2引导加载祝序grub 3.2.3grub 交互命令 3.2.4grub的启动过程 3.3Linux内核定制 3.3.1 Linux 内核 3.3.2定制Linux内核 3.4Linux应用环境的初始化 3.4.1引导配置文件inittab 3.4.2用户登录 4Shell程序设计 4.1Shell 概述 4.2Shell脚本的定义与执行 4.3Shell 变量 4.3.1 Shell变量的分类 4.3.2命令替换 4.4输入和输出 4.5Shell中的引号 4.6条件表达式 4.5.1条件表达式 4.5.2命令分隔符 4.6判断语句 4.6.1条件语句 4.6.2分支语句 4.7循环语句 4.7.1for循环语句 4.7.2while 语句 4.7.3until 语句 4.8 函数 5GNU C开发环境 5.1GNU C编译器 5.1.1目标代码的生成 5.1.2GCC 概述 5.1.3GNU C编译链接工具 5.2项目管理工具 GNU make 5.2.1项目管理概述 5.2.2基于make工具的项目管理 5.2.3Makefile 中的变量 5.2.4Makefile文件中的潜规则 5.3创建和使用函数库 5.3.1静态库 5.3.2共享库 5.3.3动态链接库 5.4GNU C 函数库——glibc 6Linux文件与目录 6.1Linux文件系统概述 6.1.1文件系统的概念 6.1.2虚拟文件系统 6.1.3文件系统的结构 6.1.4应用编程接口 6.2文件的基本输人输出 6.2.1 文件操作 6.2.2标准输人输出文件的定义 6.2.3编程实例 6.3文件属性操作 6.3.1获得文件属性 6.3.2修改文件存取权限 6.3.3改变文件的属主和属组 6.4目录操作 6.4.1目录操作 6.4.2浏览目录中的文件 6.5标准I/O库 6.5.1标准I/O库概述 6.5.2文件操作 6.5.3格式化输入与输出 6.5.4刷新缓冲区 6.6 I/O重定向 6.6.1文件描述符 6.6.2I/O重定向 6.6.3实现重定向的方法 7Linux信号 7.1信号概述 7.1.1信号的概念 7.1.2应用编程接口 7.2Linux系统中的信号 7.2.1Linux系统中的信号 7.2.2信号的分类 7.2.3 Linux信号的产生 7.2.4信号的处理方式 7.2.5信号的处理流程 7.3信号的定义 7.3.1设置信号的行为 7.3.2信号处理函数 7.3.3定义多个信号 7.3.4信号的阻塞 7.4发送信号 7.5计时器 7.5.1睡眠延迟 7.5.2间隔计时器 8Linux进程 8.1Linux进程概述 8.1.1Linux 进程 8.1.2应用编程接口 8.2进程的地址空间 8.2.1进程的地址空间 8.2.2环境变量相关操作 8.2.3命令行参数的引用 8.2.4动态内存管理 8.3进程的创建与终止 8.3.1创建进程 8.3.2程序的启动与结束 8.4加载可执行映像 8.4.1ELF格式 8.4.2可执行文件的加载 8.5进程同步控制 8.5.1等待子进程结束 8.5.2等待指定子进程 8.6 Linux进程环境 8.6.1用户和用户组 8.6.2进程和进程组 8.6.3会话 8.6.4守护进程 9Linux进程通信 9.1进程通信概述 9.1.1进程通信方式 9.1.2应用编程接口 9.2管道 9.2.1无名管道 9.2.2命名管道 9.3 IPC 概述 9.4信号量 9.4.1创建信号量 9.4.2获得与释放信号量 9.4.3信号量的控制操作 9.5消息队列 9.5.1创建消息队列 9.5.2发送消息 9.5.3接收消息 9.5.4设置消息队列属性 9.6 共享内存 9.6.1创建共享内存 9.6.2共享内存映射的建立与释放 9.6.3设置共享内存属性 10I/O操作模式 10.1 I/O操作模式概述 10.1.1 I/O操作模式 10.1.2应用编程接口 10.2同步阻塞I/O模式 10.2.1基本概念 10.2.2存在的问题 10.2.3 解决方法 10.3同步非阻塞1/0棋式 10.3.1基本概念 10.3.2实现方式 10.4多路复用I/O模式 10.4.1基本概念 10.4.2实现方法 10.5信号驱动的I/O模式 10.5.1基本概念 10.5.2实现方法 10.6异步I/O模式 10.6.1基本概念 10.6.2 实现方法 10.7内存的I/O映射 10.7.1基本概念 10.7.2:实现方法 10.8文件锁 10.8.1文件锁的类型 10.8.2基于flock函数实现文件锁 10.8.3利用fcntl函数实现文件加锁 10.9终端I/O 10.9.1终端的行为模式 10.9.2终端模式的设置 10.9.3终端I/O的编程接口 1UNIX系统概述 1.1UNIX的发展历史 1.1.1UNIX的产生与发展 1.1.2UNIX的相关标准 1.2GNU的诞生与发展 1.2.1自由软件计划GNU 1.2.2许可证协议 1.2.3自由软件和开源软件 1.3Linux 内核 1.3.1Minix操作系统 1.3.2Linux的产生与发展 1.3.3Linux内核版本 1.3.4Linux内核的分类 1.4Linux 系统 1.4.1Linux系统的概念 1.4.2GNU/Linux 1.4.3Linux 发行版 1.5Linux系统的商业运营模式 2Shell命令 2.1Shell命令概述 2.1.1目录的组织结构系统目录树： [root@VM_9_128_centos //]# tree -L 1 . |– bin -&gt; usr/bin #所有用户可使用的可执行文件 |– boot #Linux内核映像文件和与引导加载有关的文件 |– data |– dev #所有设备文件，包括字符设备和块设备 |– etc #系统配置文件 |– home |– lib -&gt; usr/lib #共享库文件，供/bin下的文件和/sbin下的文件使用 |– lib64 -&gt; usr/lib64 |– lost+found |– media |– mnt #挂载点，常用于挂载文件系统 |– opt |– proc #基于内存的文件系统，用于显示内核消息 |– project |– root |– run |– sbin -&gt; usr/sbin |– srv |– sys |– tmp |– usr |– /usr/bin #用户命令文件 |– /usr/include #C头文件 |– /usr/lib #函数库 |– /usr/src #源代码目录 |– /usr/sbin #系统命令工具 |– var `– zxLiao“/“表示根目录。为了便于管理，每个目录中存放两个特殊目录，分别表示当前目录”.”和父目录”..” 2.1.2文件的路径当”/“位于字符串首位时，表示根目录，位于两个目录之间时，表示分隔符。1.用户主目录：每个用户在登录进系统时，都位于某个目录，该目录称为用户主目录。root用户的用户主目录是/root,普通用户的用户主目录通常都是/home/username。2.绝对路径：从根目录开始到目标目录3.相对路径：从当前目录到目标目录 2.1.3Linux命令的语法结构命令常用的语法结构定义如下： $ 命令名 [选项] [参数列表]其中，$为提示符，提示符可以通过环境变量重新设置，命令名代表命令的名称，通常是可执行文件的文件名。 2.1.4Shell命令的分类根据Shell命令实现方式的不同，shell命令可分为内部命令和外部命令。1.内部命令内部命令由Shell实现，具有较高额执行效率，运行于当前进程，可以通过命令type判断是否为外部命令 type -t ls2.外部命令外部命令是指存储于文件系统中的可执行二进制映像文件。Shell创建子进程，在子进程中加载并执行外部命令。可以通过file查看外部命令的信息。 file cp 2.1.5联机帮助 man ls info cp ls --help 2.1.5联机帮助 2.2目录和文件操作 2.2.1目录操作1. pwd命令 pwd当前目录的绝对路径2.cd命令 cd 目录名改变当前目录 cd test #切换到当前目录下的test子目录 cd / #切换到系统根目录 cd .. #却换到上机目录 cd ~/demo #切换到用户主目录下的demo目录3.mkdir命令 mkdir [选项] 目录名创建指定名称的目录 mkdir test #在当前路径下创建test mkdir ~/test #在用户主目录下创建test mkdir -p /test1/test2 #创建一系列目录[-p]4、rmdir命令 rmdir [选项] 目录名删除指定名称的空目录 rmdir mydir #删除当前目录下的mydir rmdir -p dir1/dir2 #删除dir2，如果dir1也是空目录，一并删除 2.2.2文件操作1.ls命令 ls [选项] 目录或文件显示文件和目录信息|选项|含义||——–||-a|查询所有文件，包含以.开头的隐藏文件||-l|以详细列表的方式显示文件属性||-i|显示文件的i节点编号||-R|连同子目录内容一起输出|2.cp命令 cp [选项] 源文件 目标文件将源文件复制到目标文件|选项|含义||——–||-l|若目标文件已存在，指示要不要覆盖||-p|连同源文件的属性一并复制到目标文件||-r|递归复制，用于文件复制||-u|若目标文件比源文件旧，则更新目标文件| cp file1 file2 #将文件file1复制为文件file2 cp -r dir1 dir2 #递归复制dir1下的所有文件到dir2 cp -ur ~/dir1 ~/dir2 #更新dir1的备份文件dir23.rm命令 rm [选项] 文件列表删除文件列表中的文件|选项|含义||——–||-i|在删除文件前给出提示||-r|递归删除，用于删除目录||-f|强制删除，不给出提示| rm file1 file2 #删除文件file1和file2 rm r dir1 #递归删除目录dir1 rm -ir ~/dir1 #递归删除目录用户主目录下的dir1并给出提示4.mv命令 mv [选项] 文件和目录列表 目标文件将列表的所有目录和文件移动到目标目录|选项|含义||——–||-i|若目标文件已存在，提示是否要覆盖||-f|强制移动，若目标文件已存在，不进行提示||-u|若目标已存在且比较旧，则用源文件更新| mv file1 file2 #将文件file1更名为file2 mv file1 dir1 dir2 #将文件file1和目录dir1移动到目录dir25.find命令 find [目录列表] [匹配方式]在目标目录中按照匹配方式搜索符合添加的文件|匹配方式|含义||———||-name 文件名|在目录列表中查询和文件名相匹配的文件||-type x|在目录列表中检索类型为x的文件，例如d表示目录||-newer 文件名|搜索所有修改时间比file文件更新的文件||-size n|匹配所有大小为n块的文件，c在n后表示字节数||-mtime n|匹配所有在前n天内修改过的文件||-atime n|匹配所有在前n天内访问过的文件||-print |显示整个文件路径和名称||-user 用户名|搜索所有属主为用户名的文件||-exec command|匹配的文件执行command命令，命令的形式为command{}|; 2.2.3显示文本文件内容1.cat2.more3.less4.head5.tail 2.2.4硬链接和软链接 2.3用户和用户组管理 2.3.1用户的分类 2.3.2用户组管理1.groupadd命令2.groupdel命令 2.3.3用户管理1.useradd2.paddword 2.3.4用户属性的修改1.usermod2.chown 2.3.5用户管理相关配置文件 2.4文件的权限管理 2.4.1文件属性 2.4.2权限的修改 2.4.3权限验证 2.4.4权限掩码umask 2.4.5文件和目录权限的计算 2.5进程管理 2.5.1进程的管理信息 2.5.2与进程相关的命令1.pstree2.ps3.kill4.fg5.bg6.jobs 2.6Linux的备份与恢复 2.6.1面向文件的备份与恢复 2.6.2面向文件系统的备份 2.6.3面向设备的备份与恢复 2.7Linux应用软件包管理 2.7.1应用软件包的分类 2.7.2RPM软件包的管理 2.8输入输出重定向和管道 2.8.1标准输入输出文件的定义 2.8.2输人输出重定向 2.8.3管道 2.9元字符与正则表达式 2.9.1元字符 2.9.2正则表达式 3Linux系统的定制 3.1磁盘管理 3.1.1硬盘的物理结构 3.1.2磁盘分区 3.1.3分区格式化 3.1.4 ext2文件系统 3.1.5文件系统的挂载与卸载 3.2引导加载程序grub 3.2.1引导加载的概念 3.2.2引导加载祝序grub 3.2.3grub 交互命令 3.2.4grub的启动过程 3.3Linux内核定制 3.3.1 Linux 内核 3.3.2定制Linux内核 3.4Linux应用环境的初始化 3.4.1引导配置文件inittab 3.4.2用户登录 4Shell程序设计 4.1Shell 概述 4.2Shell脚本的定义与执行 4.3Shell 变量 4.4输入和输出 4.3.1 Shell变量的分类 4.3.2命令替换 4.5Shell中的引号 4.6条件表达式 4.5.1条件表达式 4.5.2命令分隔符 4.6判断语句 4.6.1条件语句 4.6.2分支语句 4.7循环语句 4.7.1for循环语句 4.7.2while 语句 4.7.3until 语句 4.8 函数 5GNU C开发环境 5.1GNU C编译器 5.1.1目标代码的生成 5.1.2GCC 概述 5.1.3GNU C编译链接工具 5.2项目管理工具 GNU make 5.2.1项目管理概述 5.2.2基于make工具的项目管理 5.2.3Makefile 中的变量 5.2.4Makefile文件中的潜规则 5.3创建和使用函数库 5.3.1静态库 5.3.2共享库 5.3.3动态链接库 5.4GNU C 函数库——glibc 6Linux文件与目录 6.1Linux文件系统概述 6.1.1文件系统的概念 6.1.2虚拟文件系统 6.1.3文件系统的结构 6.1.4应用编程接口 6.2文件的基本输人输出 6.2.1 文件操作 6.2.2标准输人输出文件的定义 6.2.3编程实例 6.3文件属性操作 6.3.1获得文件属性 6.3.2修改文件存取权限 6.3.3改变文件的属主和属组 6.4目录操作 6.4.1目录操作 6.4.2浏览目录中的文件 6.5标准I/O库 6.5.1标准I/O库概述 6.5.2文件操作 6.5.3格式化输入与输出 6.5.4刷新缓冲区 6.6 I/O重定向 6.6.1文件描述符 6.6.2I/O重定向 6.6.3实现重定向的方法 7Linux信号 7.1信号概述 7.1.1信号的概念 7.1.2应用编程接口 7.2Linux系统中的信号 7.2.1Linux系统中的信号 7.2.2信号的分类 7.2.3 Linux信号的产生 7.2.4信号的处理方式 7.2.5信号的处理流程 7.3信号的定义 7.3.1设置信号的行为 7.3.2信号处理函数 7.3.3定义多个信号 7.3.4信号的阻塞 7.4发送信号 7.5计时器 7.5.1睡眠延迟 7.5.2间隔计时器 8Linux进程 8.1Linux进程概述 8.1.1Linux 进程 8.1.2应用编程接口 8.2进程的地址空间 8.2.1进程的地址空间 8.2.2环境变量相关操作 8.2.3命令行参数的引用 8.2.4动态内存管理 8.3进程的创建与终止 8.3.1创建进程 8.3.2程序的启动与结束 8.4加载可执行映像 8.4.1ELF格式 8.4.2可执行文件的加载 8.5进程同步控制 8.5.1等待子进程结束 8.5.2等待指定子进程 8.6 Linux进程环境 8.6.1用户和用户组 8.6.2进程和进程组 8.6.3会话 8.6.4守护进程 9Linux进程通信 9.1进程通信概述 9.1.1进程通信方式 9.1.2应用编程接口 9.2管道 9.2.1无名管道 9.2.2命名管道 9.3 IPC 概述 9.4信号量 9.4.1创建信号量 9.4.2获得与释放信号量 9.4.3信号量的控制操作 9.5消息队列 9.5.1创建消息队列 9.5.2发送消息 9.5.3接收消息 9.5.4设置消息队列属性 9.6 共享内存 9.6.1创建共享内存 9.6.2共享内存映射的建立与释放 9.6.3设置共享内存属性 10I/O操作模式 10.1 I/O操作模式概述 10.1.1 I/O操作模式 10.1.2应用编程接口 10.2同步阻塞I/O模式 10.2.1基本概念 10.2.2存在的问题 10.2.3 解决方法 10.3同步非阻塞1/0棋式 10.3.1基本概念 10.3.2实现方式 10.4多路复用I/O模式 10.4.1基本概念 10.4.2实现方法 10.5信号驱动的I/O模式 10.5.1基本概念 10.5.2实现方法 10.6异步I/O模式 10.6.1基本概念 10.6.2 实现方法 10.7内存的I/O映射 10.7.1基本概念 10.7.2:实现方法 10.8文件锁 10.8.1文件锁的类型 10.8.2基于flock函数实现文件锁 10.8.3利用fcntl函数实现文件加锁 10.9终端I/O 10.9.1终端的行为模式 10.9.2终端模式的设置 10.9.3终端I/O的编程接口 附录一 命令 参数 作用 ls 列出指定目录下的所有文件[缺省是当前路径] tye 判断是什么类型的命令 file man 查询命令的操作文档 info 获得命令的相关信息 pwd 当前目录的绝对路径 * –help 获得命令的相关信息","excerpt":"本文为《GUN/Linux编程》的个人读书笔记","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/tags/Linux编程/"}]},{"title":"Flask-Web开发|学习笔记","date":"2017-04-27T03:02:03.000Z","path":"2017/04/27/Flask-Web开发[学习笔记]/","text":"本文是《Flask-Web开发:基于Python的Web应用开发实战》的个人学习笔记 目录： 安装 使用虚拟环境 使用pip安装Python包 程序的基本结构 初始化 路由和视图函数 启动服务器 一个完整的循环 请求 - 响应循环 程序和请求上下文 请求调度 请求钩子 响应 Flask扩展 模板 JinJa2 模板引擎 渲染模板 变量 控制结构 使用Flask-Bootstrap 集成 Twitter Bootstrap 自定义错误页面 链接 静态文件 使用Flask-Monment本地化日期和时间 Web表单 跨站请求伪造保护 表单类 把表单渲染成HTML 在视图函数中处理表单 重定向和用户会话 Flash消息 数据库 电子邮件 大型程序的结构 项目结构 配置选项 程序包 使用程序工厂函数 在蓝本中实现程序功能 启动脚本 需求文件 单元测试 创建数据库 用户认证 Flask的认证扩展 密码安全性 创建认证蓝本 使用Flask-Login认证用户 准备用于登录的用户模型 保护路由 添加登录表单 登入用户 登出用户 测试登录 注册新用户 添加用户注册表单 注册新用户 确认账户 使用isdangerous生成确认令牌 发送确认邮件 管理账户 用户角色 角色在数据库中的表示 赋予角色 角色验证 用户资料 资料信息 用户资料页面 资料编辑器 用户级别的资料编辑器 管理员级别的资料编辑器 用户头像 博客文章 关注者 用户评论 应用编程接口 测试 性能 部署 其他 #1安装 ##1.1 使用虚拟环境虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python解释器。虚拟环境非常有用，可以在系统的Python解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。使用虚拟环境还有个好处，那就是不需要管理员权限。虚拟环境使用第三方实用工具 virtualenv 创建。输入以下命令可以检查系统是否安装了 virtualenv： $ virtualenv --version 当你有多个项目的时候，有可能会遇到不同项目所依赖的包的版本不一致的情况，糟糕的是可能会有某些关键的外部库前后两个版本并不兼容，这个时候virtualenv就很有用处，可以为每个项目创建一个虚拟环境，这样各个项目之间就不会冲突 如果结果显示错误，你就需要安装这个工具。使用以下命令安装： $ sudo yum install virtualenv 下一步是使用 virtualenv 命令在 flasky 文件夹中创建 Python 虚拟环境。这个命令只有一 个必需的参数，即虚拟环境的名字。创建虚拟环境后，当前文件夹中会出现一个子文件 夹，名字就是上述命令中指定的参数，与虚拟环境相关的文件都保存在这个子文件夹中。 按照惯例，一般虚拟环境会被命名为 venv： $ virtualenv venv New python executable in venv/bin/python2.7 Also creating executable in venv/bin/python Installing setuptools............done. Installing pip...............done. 现在，flasky文件夹中就有了一个名为venv的子文件夹，它保存一个全新的虚拟环境，其 中有一个私有的 Python 解释器。在使用这个虚拟环境之前，你需要先将其“激活”。如果 你使用 bash 命令行（Linux 和 Mac OS X 用户），可以通过下面的命令激活这个虚拟环境： $ source venv/bin/activate 虚拟环境被激活后，其中 Python 解释器的路径就被添加进 PATH 中，但这种改变不是永久 性的，它只会影响当前的命令行会话。为了提醒你已经激活了虚拟环境，激活虚拟环境的 命令会修改命令行提示符，加入环境名： (venv) $ 当虚拟环境中的工作完成后，如果你想回到全局 Python 解释器中，可以在命令行提示符下 输入 deactivate ##1.2 使用pip安装Python包大多数 Python 包都使用 pip 实用工具安装，使用 virtualenv 创建虚拟环境时会自动安装 pip。激活虚拟环境后，pip 所在的路径会被添加进 PATH。 执行下述命令可在虚拟环境中安装 Flask： (venv) $ pip install flask 执行上述命令，你就在虚拟环境中安装 Flask 及其依赖了。要想验证 Flask 是否正确安装， 你可以启动 Python 解释器，尝试导入 Flask： (venv) $ python &gt;&gt;&gt; import flask &gt;&gt;&gt; 如果没有看到错误提醒，就说明Flask安装完毕。 #2 程序的基本结构 ##2.1 初始化 所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口 （Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这 个对象处理。程序实例是 Flask 类的对象，经常使用下述代码创建： from flask import Flask app = Flask(__name__) Flask 类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序 中，Python 的 ‘name‘ 变量就是所需的值。 ##2.2 路由和视图函数客户端（例如 Web 浏览器）把请求发送给 Web 服务器，Web 服务器再把请求发送给 Flask程序实例。程序实例需要知道对每个 URL 请求运行哪些代码，所以保存了一个 URL 到 Python 函数的映射关系。处理URL和函数之间关系的程序称为路由。 路由可以理解为请求的URL 在 Flask 程序中定义路由的最简便方式，是使用程序实例提供的 app.route 修饰器，把修 饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由： @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; 上例把 index() 函数注册为程序根地址的处理程序。如果部署程序的服务器域名为 www. example.com，在浏览器中访问 http://www.example.com 后，会触发服务器执行 index() 函 数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是 Web 浏览器，响 应就是显示给用户查看的文档。像index()这样的函数称为视图函数（view function）。视图函数返回的响应可以是包含 HTML 的简单字符串，也可以是复杂的表单。 如果你仔细观察日常所用服务的某些 URL 格式，会发现很多地址中都包含可变部分。例 如， 你 的 Facebook 资 料 页 面 的 地 址 是 http://www.facebook.com/， 用 户 名 （your-name）是地址的一部分。Flask 支持这种形式的 URL，只需在 route 修饰器中使用特 殊的句法即可。下例定义的路由中就有一部分是动态名字： @app.route(&apos;/user/&lt;name&gt;&apos;) def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name 尖括号中的内容就是动态部分，任何能匹配静态部分的 URL 都会映射到这个路由上。调 用视图函数时，Flask 会将动态部分作为参数传入函数。在这个视图函数中，参数用于生 成针对个人的欢迎消息。 路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由 /user/ 只会匹配动态片段 id 为整数的 URL。Flask 支持在路由中使用 int、float 和 path 类型。 path 类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。 ##2.3 启动服务器程序实例用 run 方法启动 Flask 集成的开发 Web 服务器： if __name__ == &apos;__main__&apos;: app.run(debug=True) debug模式打开的情况下如果程序出错可以在浏览器中看到报错信息 __name__==&#39;__main__&#39;是 Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发 Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因 此不会执行 app.run()。服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按 Ctrl-C 键。有一些选项参数可被 app.run() 函数接受用于设置 Web 服务器的操作模式。在开发过程中 启用调试模式会带来一些便利，比如说激活调试器和重载程序。要想启用调试模式，我们 可以把 debug 参数设为 True。 ##2.4 一个完整的程序前几节介绍了 Flask Web 程序的不同组成部分，现在是时候开发一个程序了。整个 hello.py 程序脚本就是把前面介绍的三部分合并到一个文件中。程序代码如示例 2-1 所示。一个完整的 Flask 程序: from flask import Flask app = Flask(__name__) @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; if __name__ == &apos;__main__&apos;: app.run(debug=True) 打开 Web 浏览器，在地址栏中输入 http://127.0.0.1:5000/ 即可看到返回的 Hello World! from flask import Flask app = Flask(__name__) @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; @app.route(&apos;/user/&lt;name&gt;&apos;) #动态路由 def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name if __name__ == &apos;__main__&apos;: app.run(debug=True) 访问 http://localhost:5000/user/Dave。 程序会显示一个使用 name 动态参数生成的欢迎消息。尝试使用不同的名字，可以看到视 图函数总是使用指定的名字生成响应. ##2.5 请求-响应循环 ###2.5.1 程序和请求上下文Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对 象就是一个很好的例子，它封装了客户端发送的 HTTP 请求。要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数， 不过这会导致程序中的每个视图函数都增加一个参数。除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。为了避免大量可有可无的参数把视图函数弄得一团糟，Flask 使用上下文临时把某些对象 变为全局可访问。有了上下文，就可以写出下面的视图函数： from flask import request @app.route(&apos;/&apos;) def index(): user_agent = request.headers.get(&apos;User-Agent&apos;) return &apos;&lt;p&gt;Your browser is %s&lt;/p&gt;&apos; % user_agent request.headers.get(‘User-Agent’)可以获得客户端发过来的请求的请求头中的User-Agent 变量名 上下文 说明 current_app 程序上下文 当前激活程序的程序实例 g 程序上下文 处理请求时用作临时存储的对象。每次请求都会重设这个变量 request 请求上下文 请求对象，封装了客户端发出的 HTTP 请求中的内容 session 请求上下文 用户会话，用于存储请求之间需要“记住”的值的词典 注意在这个视图函数中我们如何把 request 当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时， 每个线程看到的 request 对象必然不同。Falsk 使用上下文让特定的变量在一个线程中全局 可访问，与此同时却不会干扰其他线程 在 Flask 中有两种上下文：程序上下文和请求上下文。 Flask 在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。程 序上下文被推送后，就可以在线程中使用 current_app 和 g 变量。类似地，请求上下文被 推送后，就可以使用 request 和 session 变量。如果使用这些变量时我们没有激活程序上 下文或请求上下文，就会导致错误。 ###2.5.2 请求调度程序收到客户端发来的请求时，要找到处理该请求的视图函数。为了完成这个任务，Flask 会在程序的 URL 映射中查找请求的 URL。URL 映射是 URL 和视图函数之间的对应关系。 Flask 使用 app.route 修饰器或者非修饰器形式的 app.add_url_rule() 生成映射。要想查看 Flask 程序中的 URL 映射是什么样子，我们可以在 Python shell 中检查为 hello.py 生成的映射。测试之前，请确保你激活了虚拟环境： (venv) $ python &gt;&gt;&gt; from hello import app &gt;&gt;&gt; app.url_map Map([&lt;Rule &apos;/&apos; (HEAD, OPTIONS, GET) -&gt; index&gt;, &lt;Rule &apos;/static/&lt;filename&gt;&apos; (HEAD, OPTIONS, GET) -&gt; static&gt;, &lt;Rule &apos;/user/&lt;name&gt;&apos; (HEAD, OPTIONS, GET) -&gt; user&gt;]) / 和 /user/ 路由在程序中使用 app.route 修饰器定义。/static/ 路由是 Flask 添加的特殊路由，用于访问静态文件。 URL 映射中的 HEAD、Options、GET 是请求方法，由路由进行处理。Flask 为每个路由都指 定了请求方法，这样不同的请求方法发送到相同的 URL 上时，会使用不同的视图函数进 行处理。HEAD 和 OPTIONS 方法由 Flask 自动处理，因此可以这么说，在这个程序中，URL 映射中的 3 个路由都使用 GET 方法。 2.5.3 请求钩子有时在处理请求之前或之后执行代码会很有用。例如，在请求开始时，我们可能需要创 建数据库连接或者认证发起请求的用户。为了避免在每个视图函数中都使用重复的代码， Flask 提供了注册通用函数的功能，注册的函数可在请求被分发到视图函数之前或之后 调用。 请求钩子使用修饰器实现。Flask 支持以下 4 种钩子。 • ：注册一个函数，在处理第一个请求之前运行。 before_request• ：注册一个函数，在每次请求之前运行。 after_request• ：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。 teardown_request• ：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。 在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量 g。例如，before_ request 处理程序可以从数据库中加载已登录用户，并将其保存到 g.user 中。随后调用视 图函数时，视图函数再使用 g.user 获取用户。 ###2.5.4 响应Flask 调用视图函数后，会将其返回值作为响应的内容。大多数情况下，响应就是一个简 单的字符串，作为 HTML 页面回送客户端。但 HTTP 协议需要的不仅是作为请求响应的字符串。HTTP 响应中一个很重要的部分是状 态码，Flask 默认设为 200，这个代码表明请求已经被成功处理。如果视图函数返回的响应需要使用不同的状态码，那么可以把数字代码作为第二个返回 值，添加到响应文本之后。例如，下述视图函数返回一个 400 状态码，表示请求无效： @app.route(&apos;/&apos;) def index(): return &apos;&lt;h1&gt;Bad Request&lt;/h1&gt;&apos;, 400 视图函数返回的响应还可接受第三个参数，这是一个由首部（header）组成的字典，可以 添加到 HTTP 响应中。如果不想返回由 1 个、2 个或 3 个值组成的元组，Flask 视图函数还可以返回 Response对象。make_response() 函数可接受 1 个、2 个或 3 个参数（和视图函数的返回值一样），并返回一个 Response对象。有时我们需要在视图函数中进行这种转换，然后在响应对象上调用各种方法，进一步设置响应。下例创建了一个响应对象，然后设置了 cookie： from flask import make_response @app.route(&apos;/&apos;) def index(): response = make_response(&apos;&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;&apos;) response.set_cookie(&apos;answer&apos;, &apos;42&apos;) return response 有一种名为重定向的特殊响应类型。这种响应没有页面文档，只告诉浏览器一个新地址用 以加载新页面。重定向经常使用 302 状态码表示，指向的地址由 Location 首部提供。重定向响应可以使用 3 个值形式的返回值生成，也可在 Response 对象中设定。不过，由于使用频繁，Flask 提 供了 redirect() 辅助函数，用于生成这种响应： from flask import redirect @app.route(&apos;/&apos;) def index(): return redirect(&apos;http://www.example.com&apos;) 还有一种特殊的响应由 abort 函数生成，用于处理错误。在下面这个例子中，如果 URL 中 动态参数 id 对应的用户不存在，就返回状态码 404： from flask import abort @app.route(&apos;/user/&lt;id&gt;&apos;) def get_user(id): user = load_user(id) if not user: abort(404) return &apos;&lt;h1&gt;Hello, %s&lt;/h1&gt;&apos; % user.name 注意，abort 不会把控制权交还给调用它的函数，而是抛出异常把控制权交给 Web 服 务器。 #3. 模板 ##3.1 Jinja2模板引擎形式最简单的 Jinja2 模板就是一个包含响应文本的文件。templates/index.html：Jinja2 模板 &lt;h1&gt;Hello World!&lt;/h1&gt; templates/user.html：Jinja2 模板(带有变量) &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; ##3.1.1 渲染模板默认情况下，Flask 在程序文件夹中的 templates 子文件夹中寻找模板。在下一个 hello.py 版本中，要把前面定义的模板保存在 templates 文件夹中，并分别命名为 index.html 和 user. html。 from flask import Flask, render_template # ... @app.route(&apos;/&apos;) def index(): return render_template(&apos;index.html&apos;) @app.route(&apos;/user/&lt;name&gt;&apos;) def user(name): return render_template(&apos;user.html&apos;, name=name) Flask 提供的 render_template 函数把 Jinja2 模板引擎集成到了程序中。render_template 函 数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。在这段代码中，第二个模板收到一个名为 name 的变量。前例中的 name=name 是关键字参数，这类关键字参数很常见，但如果你不熟悉它们的话， 可能会觉得迷惑且难以理解。左边的“name”表示参数名，就是模板中使用的占位符；右 边的“name”是当前作用域中的变量，表示同名参数的值。 ##3.1.2 变量在模板中使用的结构表示一个变量，它是一种特殊的占位符，告诉模 板引擎这个位置的值从渲染模板时使用的数据中获取。Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。在模板 中使用变量的一些示例如下： &lt;p&gt;A value from a dictionary: {{ mydict['key'] }}.&lt;/p&gt; &lt;p&gt;A value from a list: {{ mylist[3] }}.&lt;/p&gt; &lt;p&gt;A value from a list, with a variable index: {{ mylist[myintvar] }}.&lt;/p&gt; &lt;p&gt;A value from an object&apos;s method: {{ myobj.somemethod() }}.&lt;/p&gt; 可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述 模板以首字母大写形式显示变量 name 的值： Hello, {{ name|capitalize }} 过滤器名 说 明 safe 渲染值时不转义 capitalize 把值的首字母转换成大写，其他字母转换成小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格去掉 striptags 渲染之前把值中所有的 HTML 标签都删掉 safe 过滤器值得特别说明一下。默认情况下，出于安全考虑，Jinja2 会转义所有变量。 例 如，如果一个变量的值为 &apos;&lt;h1&gt;Hello&lt;/h1&gt;&apos;， Jinja2 会将其渲染成 &apos;&amp;lt;h1&amp;gt;Hello&amp;lt;/ h1&amp;gt;&apos;， 浏览器能显示这个 h1 元素，但不会进行解释。 很多情况下需要显示变量中存储 的 HTML 代码，这时就可使用 safe 过滤器。 千万别在不可信的值上使用 safe 过滤器，例如用户在表单中输入的文本。 ###3.1.3 控制结构Jinja2 提供了多种控制结构，可用来改变模板的渲染流程。本节使用简单的例子介绍其中 最有用的控制结构。下面这个例子展示了如何在模板中使用条件控制语句： {% if user %} Hello, {{ user }}! {% else %} Hello, Stranger! {% endif %} 另一种常见需求是在模板中渲染一组元素。下例展示了如何使用 for 循环实现这一需求： &lt;ul&gt; {% for comment in comments %} {{ comment }} {% endfor %} &lt;/ul&gt; Jinja2 还支持宏。宏类似于 Python 代码中的函数。例如： {% macro render_comment(comment) %} {{ comment }} {% endmacro %} &lt;ul&gt; {% for comment in comments %} {{ render_comment(comment) }} {% endfor %} &lt;/ul&gt; 为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入： {% import 'macros.html' as macros %} &lt;ul&gt; {% for comment in comments %} {{ macros.render_comment(comment) }} {% endfor %} &lt;/ul&gt; `需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免 重复： {% include 'common.html' %} 另一种重复使用代码的强大方式是模板继承，它类似于 Python 代码中的类继承。首先，创 建一个名为 base.html 的基模板： &lt;html&gt; &lt;head&gt; {% block head %} {% block title %}{% endblock %} - My Application&lt;/title&gt; {% endblock %} &lt;/head&gt; &lt;body&gt; {% block body %} {% endblock %} &lt;/body&gt; &lt;/html&gt; block 标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为 head、title 和 body 的块。注意，title 包含在 head 中。下面这个示例是基模板的衍生模板： {% extends \"base.html\" %} {% block title %}Index{% endblock %} {% block head %} {{ super() }} {% endblock %} {% block body %} Hello, World! {% endblock %} extends 指令声明这个模板衍生自 base.html。在 extends 指令之后，基模板中的 3 个块被 重新定义，模板引擎会将其插入适当的位置。注意新定义的 head 块，在基模板中其内容不 是空的，所以使用 super() 获取原来的内容。 ##3.3 自定义错误页面 如果你在浏览器的地址栏中输入了不可用的路由，那么会显示一个状态码为 404 的错误页 面。现在这个错误页面太简陋、平庸，而且样式和使用了 Bootstrap 的页面不一致。像常规路由一样，Flask 允许程序使用基于模板的自定义错误页面。最常见的错误代码有 两个：404，客户端请求未知页面或路由时显示；500，有未处理的异常时显示。为这两个 错误代码指定自定义处理程序的方式如示例 3-6 所示。自定义错误页面 @app.errorhandler(404) def page_not_found(e): return render_template(&apos;404.html&apos;), 404 @app.errorhandler(500) def internal_server_error(e): return render_template(&apos;500.html&apos;), 500 和视图函数一样，错误处理程序也会返回响应。它们还返回与该错误对应的数字状态码。错误处理程序中引用的模板也需要编写。这些模板应该和常规页面使用相同的布局，因此 要有一个导航条和显示错误消息的页面头部。编写这些模板最直观的方法是复制 templates/user.html，分别创建 templates/404.html 和templates/500.html，然后把这两个文件中的页面头部元素改为相应的错误消息。但这种方 法会带来很多重复劳动。Jinja2 的模板继承机制可以帮助我们解决这一问题。Flask-Bootstrap 提供了一个具有页面基 本布局的基模板，同样，程序可以定义一个具有更完整页面布局的基模板，其中包含导航 条，而页面内容则可留到衍生模板中定义。示例 3-7 展示了 templates/base.html 的内容，这 是一个继承自 bootstrap/base.html 的新模板，其中定义了导航条。这个模板本身也可作为其 他模板的基模板，例如 templates/user.html、templates/404.html 和 templates/500.html。示例 3-7 templates/base.html：包含导航条的程序基模板 {% extends \"bootstrap/base.html\" %} {% block title %}Flasky{% endblock %} {% block navbar %} Toggle navigation Flasky Home {% endblock %} {% block content %} {% block page_content %}{% endblock %} &lt;/div&gt; {% endblock %} 这个模板的content块中只有一个&lt;div&gt;容器，其中包含了一个名为page_content的新的空块，块中的内容由衍生模板定义。现在，程序使用的模板继承自这个模板，而不直接继承自Flask-Bootstrap的基模板。通过继承templates/base.html 模板编写自定义的 404 错误页面很简单示例 3-8 templates/404.html：使用模板继承机制自定义 404 错误页面 {% extends \"base.html\" %} {% block title %}Flasky - Page Not Found{% endblock %} {% block page_content %} Not Found {% endblock %} 错误页面在浏览器中的显示效果如图 3-2 所示。templates/user.html 现在可以通过继承这个基模板来简化内容，如示例 3-9 所示。示例 3-9 templates/user.html：使用模板继承机制简化页面模板 {% extends \"base.html\" %} {% block title %}Flasky{% endblock %} {% block page_content %} Hello, {{ name }}! {% endblock %} ##3.4 链接任何具有多个路由的程序都需要可以连接不同页面的链接，例如导航条。在模板中直接编写简单路由的 URL 链接不难，但对于包含可变部分的动态路由，在模板 中构建正确的 URL 就很困难。而且，直接编写 URL 会对代码中定义的路由产生不必要的 依赖关系。如果重新定义路由，模板中的链接可能会失效。为了避免这些问题，Flask 提供了 url_for() 辅助函数，它可以使用程序 URL 映射中保存 的信息生成 URL。url_for() 函数最简单的用法是以视图函数名（或者 app.add_url_route() 定义路由时使用 的端点名）作为参数，返回对应的 URL。例如，在当前版本的 hello.py 程序中调用 url_for(‘index’) 得到的结果是/。调用 url_for(‘index’, _external=True) 返回的则是绝对地址，在这个示例中是 http://localhost:5000/。 ##3.5 静态文件Web 程序不是仅由 Python 代码和模板组成。大多数程序还会使用静态文件，例如 HTML 代码中引用的图片、JavaScript 源码文件和 CSS。默认设置下，Flask 在程序根目录中名为 static 的子目录中寻找静态文件。如果需要，可在 static 文件夹中使用子文件夹存放文件。服务器收到前面那个 URL 后，会生成一个响应， 包含文件系统中 static/css/styles.css 文件的内容。 示例 3-10 展示了如何在程序的基模板中放置 favicon.ico 图标。这个图标会显示在浏览器的 地址栏中。示例 3-10 templates/base.html：定义收藏夹图标 {% block head %} {{ super() }} {% endblock %} 图标的声明会插入 head 块的末尾。注意如何使用 super() 保留基模板中定义的块的原始 内容。 Web表单请求对象包含客户端发出的所有请求信息。其中，request.form 能获取 POST 请求中提交的表单数据。尽管 Flask 的请求对象提供的信息足够用于处理 Web 表单，但有些任务很单调，而且要重 复操作。比如，生成表单的 HTML 代码和验证提交的表单数据。Flask-WTF（http://pythonhosted.org/Flask-WTF/）扩展可以把处理 Web 表单的过程变成一 种愉悦的体验。这个扩展对独立的 WTForms（http://wtforms.simplecodes.com）包进行了包 装，方便集成到 Flask 程序中。Flask-WTF 及其依赖可使用 pip 安装： (venv) $ pip install flask-wtf ##4.1 跨站请求伪造保护默认情况下，Flask-WTF 能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery， CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发 CSRF 攻击。为了实现 CSRF 保护，Flask-WTF 需要程序设置一个密钥。Flask-WTF 使用这个密钥生成 加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如示例 4-1 所示。 示例 4-1 hello.py：设置 Flask-WTF app = Flask(__name__) app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos; app.config 字典可用来存储框架、扩展和程序本身的配置变量。使用标准的字典句法就能 把配置值添加到 app.config 对象中。这个对象还提供了一些方法，可以从文件或环境中导 入配置值。SECRET_KEY 配置变量是通用密钥，可在 Flask 和多个第三方扩展中使用。如其名所示，加 密的强度取决于变量值的机密程度。不同的程序要使用不同的密钥，而且要保证其他人不 知道你所用的字符串。 ##4.2 表单类使用 Flask-WTF 时，每个 Web 表单都由一个继承自 Form 的类表示。这个类定义表单中的 一组字段，每个字段都用对象表示。字段对象可附属一个或多个验证函数。验证函数用来 验证用户提交的输入值是否符合要求。示例 4-2 是一个简单的 Web 表单，包含一个文本字段和一个提交按钮。示例 4-2 hello.py：定义表单类 from flask.ext.wtf import Form from wtforms import StringField, SubmitField from wtforms.validators import Required class NameForm(Form): name = StringField(&apos;What is your name?&apos;, validators=[Required()]) submit = SubmitField(&apos;Submit&apos;) 这个表单中的字段都定义为类变量，类变量的值是相应字段类型的对象。在这个示例中， NameForm 表单中有一个名为 name 的文本字段和一个名为 submit 的提交按钮。StringField 类表示属性为 type=”text” 的 &lt;input&gt; 元素。SubmitField 类表示属性为 type=”submit” 的 &lt;input&gt; 元素。字段构造函数的第一个参数是把表单渲染成 HTML 时使用的标号。StringField 构造函数中的可选参数 validators 指定一个由验证函数组成的列表，在接受 用户提交的数据之前验证数据。验证函数 Required() 确保提交的字段不为空。 WTForms 支持的 HTML 标准字段 字段类型 说 明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段，值为 datetime.date 格式 DateTimeField 文本字段，值为 datetime.datetime 格式 IntegerField 文本字段，值为整数 DecimalField 文本字段，值为 decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框，值为 True 和 False RadioField 一组单选框 SelectField 下拉列表 SelectMultipleField 下拉列表，可选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 一组指定类型的字段 WTForms 内建的验证函数 验证函数 说 明 Email 验证电子邮件地址 EqualTo 比较两个字段的值；常用于要求输入两次密码进行确认的情况 IPAddress 验证 IPv4 网络地址 Length 验证输入字符串的长度 NumberRange 验证输入的值在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段中有数据 Regexp 使用正则表达式验证输入值 URL 验证 URL AnyOf 确保输入值在可选值列表中 NoneOf 确保输入值不在可选值列表中 ##4.3 把表单渲染成HTML表单字段是可调用的，在模板中调用后会渲染成 HTML。假设视图函数把一个 NameForm 实例通过参数 form 传入模板，在模板中可以生成一个简单的表单，如下所示： &lt;form method=&quot;POST&quot;&gt; {{ form.hidden_tag() }} {{ form.name.label }} {{ form.name() }} {{ form.submit() }} &lt;/form&gt; 当然，这个表单还很简陋。要想改进表单的外观，可以把参数传入渲染字段的函数，传入 的参数会被转换成字段的 HTML 属性。例如，可以为字段指定 id 或 class 属性，然后定义CSS 样式： &lt;form method=&quot;POST&quot;&gt; {{ form.hidden_tag() }} {{ form.name.label }} {{ form.name(id='my-text-field') }} {{ form.submit() }} &lt;/form&gt; 即便能指定 HTML 属性，但按照这种方式渲染表单的工作量还是很大，所以在条件允许的 情况下最好能使用 Bootstrap 中的表单样式。Flask-Bootstrap 提供了一个非常高端的辅助函 数，可以使用 Bootstrap 中预先定义好的表单样式渲染整个 Flask-WTF 表单，而这些操作 只需一次调用即可完成。使用 Flask-Bootstrap，上述表单可使用下面的方式渲染： {% import \"bootstrap/wtf.html\" as wtf %} {{ wtf.quick_form(form) }} import 指令的使用方法和普通 Python 代码一样，允许导入模板中的元素并用在多个模板 中。导入的 bootstrap/wtf.html 文件中定义了一个使用 Bootstrap 渲染 Falsk-WTF 表单对象 的辅助函数。wtf.quick_form() 函数的参数为 Flask-WTF 表单对象，使用 Bootstrap 的默认 样式渲染传入的表单。hello.py 的完整模板如示例 4-3 所示。示例 4-3 templates/index.html：使用 Flask-WTF 和 Flask-Bootstrap 渲染表单 {% extends \"base.html\" %} {% import \"bootstrap/wtf.html\" as wtf %} {% block title %}Flasky{% endblock %} {% block page_content %} Hello, {% if name %}{{ name }} {% else %}Stranger{% endif %}! {{ wtf.quick_form(form) }} {% endblock %} 模板的内容区现在有两部分。第一部分是页面头部，显示欢迎消息。这里用到了一个模板 条件语句。Jinja2 中的条件语句格式为 ...。 如果条件的计算结果为 True，那么渲染 if 和 else 指令之间的值。如果条件的计算结果为 False，则渲染 else 和 endif 指令之间的值。在这个例子中，如果没有定义模板变量 name，则会渲染字符串“Hello, Stranger!”。内容区的第二部分使用 wtf.quick_form() 函数渲染 NameForm 对象。 ##4.4 在视图函数中处理表单这一次视图函数 index() 不仅要渲染表单，还要接收表单中的数据。示例 4-4 是更新后的 index() 视图函数。示例 4-4 hello.py：路由方法 @app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = &apos;&apos; return render_template(&apos;index.html&apos;, form=form, name=name) app.route 修饰器中添加的 methods 参数告诉 Flask 在 URL 映射中把这个视图函数注册为 GET 和 POST 请求的处理程序。如果没指定 methods 参数，就只把视图函数注册为 GET 请求 的处理程序。把 POST 加入方法列表很有必要，因为将提交表单作为 POST 请求进行处理更加便利。表单 也可作为 GET 请求提交，不过 GET 请求没有主体，提交的数据以查询字符串的形式附加到 URL 中，可在浏览器的地址栏中看到。基于这个以及其他多个原因，提交表单大都作为 POST 请求进行处理。局部变量 name 用来存放表单中输入的有效名字，如果没有输入，其值为 None。如上述代 码所示，在视图函数中创建一个 NameForm 类实例用于表示表单。提交表单后，如果数据能 被所有验证函数接受，那么 validate_on_submit() 方法的返回值为 True，否则返回 False。 这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。用户第一次访问程序时，服务器会收到一个没有表单数据的 GET 请求，所以 validateon submit() 将返回 False。if 语句的内容将被跳过，通过渲染模板处理请求，并传入表单对 象和值为 None 的 name 变量作为参数。用户会看到浏览器中显示了一个表单。用户提交表单后，服务器收到一个包含数据的 POST 请求。validate_on_submit() 会调用 name 字段上附属的 Required() 验证函数。如果名字不为空，就能通过验证，validateon submit() 返回 True。现在，用户输入的名字可通过字段的 data 属性获取。在 if 语句中， 把名字赋值给局部变量 name，然后再把 data 属性设为空字符串，从而清空表单字段。最 后一行调用 render_template() 函数渲染模板，但这一次参数 name 的值为表单中输入的名 字，因此会显示一个针对该用户的欢迎消息。","excerpt":"本文是《Flask-Web开发:基于Python的Web应用开发实战》的个人学习笔记","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"后台开发","slug":"后台开发","permalink":"http://yoursite.com/tags/后台开发/"}]},{"title":"hexo+Github搭建个人博客","date":"2017-04-02T07:33:53.000Z","path":"2017/04/02/hexo-Github搭建个人博客/","text":"&lt;未完待续&gt; 这篇博文记录一下利用gtihub的github page和hexo搭建个人博客的方法顺便作为一个教程。 Git Bash Git介绍 下载 安装 配置 markdown markdown介绍 下载 安装 markdown简单语法 sublime sublime介绍 sublime下载 sublime安装 hexo hexo介绍 hexo下载 hexo配置文件介绍 hexo操作示例 Node.jsnodejs具体安装步骤详情看这个链接 GithubGithub的介绍、注册、添加仓库以及配置SSH详情看这个链接 安装markdown1.下载 √2.安装 √3.破解 √4.基本语法 √ ##安装Git Bash1.下载 √2.安装 √ 现在需要安装hexo(就是博客的模板)","excerpt":"","categories":[],"tags":[{"name":"关于此博客","slug":"关于此博客","permalink":"http://yoursite.com/tags/关于此博客/"}]},{"title":"HTTP协议","date":"2017-03-30T06:28:53.000Z","path":"2017/03/30/HTTP协议/","text":"http请求头目录： 请求方法 状态码 通用 通用头域 请求头(Requests Headers) 响应头(Response) ##请求方法 请求方法有以下这些，常用的是GET,POST GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 ##状态码 所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 &gt;的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 常见状态代码、状态描述、说明： 200 OK //请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ##通用 Request URL:https://zhuanlan.zhihu.com/p/25296437请求网址：这个对应HTTP协议中的统一资源定位符也就是我们打开的网址 Request Method:GET请求方法：这个对应HTTP协议中的请求方法 Status Code:200 OK状态码：这个对应HTTP协议中的状态码 ##通用头域通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。 实体 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。 Cache-Control头域 Cache- Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下： Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Connection:keep-alive HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。 Content-Encoding Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。 Content-Type 用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 如果未指定 ContentType，默认为TEXT/HTML。 用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头 Date头域 Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 Expires（过期时间）HTTP头信息 Expires（过期时间） 属性是HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修 改。 Expires 头信息：对于设置静态图片文件（例如导航栏和图片按钮）可缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对 用户变得相应非常快；他们对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存 服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的“刷新”按钮。 Pragma头域 Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。 Host头域 Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。 Referer头域 Referer 头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。 Range头域 Range头域可以请求实体的一个或者多个子范围。例如， 表示头500个字节：bytes=0-499 表示第二个500字节：bytes=500-999 表示最后500个字节：bytes=-500 表示500字节以后的范围：bytes=500- 第一个和最后一个字节：bytes=0-0,-1 同时指定几个范围：bytes=500-600,601-999 但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）。 ##请求头(Requests Headers) Host头域 Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。 当前请求网址的请求域 User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 用户是通过什么工具来请求的 User-Agent头域的内容包含发出请求的用户信息。 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。 Accept-Language:zh-CN,zh;q=0.8 Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受 Accept-Encoding:gzip, deflate, sdch, br Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 Content-Type 用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。 如果未指定 ContentType，默认为TEXT/HTML。 在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 例如： Content-Type: text/html;charset:utf-8; 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。 Content-Encoding Accept-Encoding 和 Content-Encoding 是 HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过 Accept-Encoding 带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；浏览器拿到响应正文后，依据 Content-Encoding 进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。 内容编码目的是优化传输内容大小，通俗地讲就是进行压缩。一般经过 gzip 压缩过的文本响应，只有原始大小的 1/4。对于文本类响应是否开启了内容压缩，是我们做性能优化时首先要检查的重要项目；而对于 JPG / PNG 这类本身已经高度压缩过的二进制文件，不推荐开启内容压缩，效果微乎其微还浪费 CPU。 Referer:https://www.zhihu.com/people/pa-chong-21/activities 是通过哪个页面到当前页面的（也就是上一个页面是什么？） 举个例子，当我是通过百度搜索页面点到当前页面的，那么Referer就是百度搜索页 Content-Length 用于描述HTTP消息实体的传输长度。 消息实体长度：即Entity-length，压缩之前的message-body的长度 消息实体的传输长度：Content-length，压缩后的message-body的长度。 Origin origin主要是用来说明最初请求是从哪里发起的； origin只用于Post请求，而Referer则用于所有类型的请求； origin的方式比Referer更安全点吧。 Cookie:d_c0=&quot;AACAWNtZswqPTnJ8dFXqaygiq82ekPD5_-xxxx 举个例子，当我登录知乎后，知乎会给我一个cookie，然后我在以后的一段时间内，每次打开知乎，都不需要重新登录。这是因为浏览器每次都会把我之前存储的cookie带上。 Connection:keep-alive HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。 Upgrade Insecure Requests 我们的页面是 https 的，而这个页面中包含了大量的 http 资源（图片、iframe等），页面一旦发现存在上述响应头，会在加载 http 资源时自动替换成 https 请求。 Cache-Control:no-cache Cache-Control 是用来控制网页的缓存 If-Modified-Since:Wed, 15 Feb 2017 09:14:13 GMT(缓存时间) If-None-Match:W/&quot;58a41be5-190aa&quot; Last-Modified:Wed, 15 Feb 2017 09:14:13 GMT ETag:&quot;58a41be5-190aa&quot; 这4个一般静态页面会用到 If-Modified-Since,If-None-Match这两个是请求头，ETag,Last-Modified是返回头（服务器返回的） 如果If-Modified-Since的值和Last-Modified相等 则表明当前请求的内容没有变动，服务器返回,If-None-Match和ETag 同理 ##响应头(Response) Public-Key- Pins Public-Key- Pins (PKP)的目的主要是允许网站经营者提供一个哈希过的公共密钥存储在用户的浏览器缓存里。跟Strict-Transport-Security功能相 似的是，它能保护用户免遭中间人攻击。这个header可能包含多层的哈希运算，比如pin-sha256=base64(sha256(SPKI))， 具体是先将 X.509 证书下的Subject Public Key Info (SPKI) 做sha256哈希运算，然后再做base64编码。然而，这些规定有可能更改，例如有人指出，在引号中封装哈希是无效的，而且在33版本的chrome 中也不会保存pkp的哈希到缓存中。 这个header和 STS的作用很像，因为它规定了最大子域名的数量。此外，pkp还提供了一个Public-Key-Pins-Report-Only 头用来报告异常，但是不会强制阻塞证书信息。当然，这些chrome都是不支持的。 Server响应头 Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。 来自： http://blog.csdn.net/mm2223/article/details/8089645/http://fex.baidu.com/blog/2014/05/what-happen/ (计算机网络)http://blog.csdn.net/blueheart20/article/details/45174399 (请求头、响应头)http://www.tuicool.com/articles/b6BNNfN (Accept-Encoding 和 Content-Encoding)","excerpt":"http请求头目录： 请求方法 状态码 通用 通用头域 请求头(Requests Headers) 响应头(Response)","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Python网络爬虫与信息提取","date":"2017-03-30T06:16:22.000Z","path":"2017/03/30/Python网络爬虫与信息提取/","text":"#Python网络爬虫与信息提取这个笔记是跟着北京理工大学计算机学院「嵩天副教授」在中国大学MOOC上的课程《Python网络爬虫与信息提取》所做的学习笔记 ##requests库的get()方法 r = requests.get()其中requests.get()是构造一个向服务器请求资源的Request对象其中r是一个包含服务器资源的Response对象 # -*- coding=UTF-8 -*- # 2017年2月28日17:40:30 import requests url = &apos;http://www.baidu.com&apos; r = requests.get(url) print type(r) #打印r的类型 print r.status_code #打印http请求返回的状态码 print r.headers #打印响应头 运行结果： &lt;class &apos;requests.models.Response&apos;&gt; 200 {&apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Set-Cookie&apos;: &apos;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&apos;, &apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Last-Modified&apos;: &apos;Mon, 23 Jan 2017 13:28:26 GMT&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 09:39:57 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;} Response对象的属性 属性 说明 r.status_code HTTP请求返回的状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式。即URL对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的相应内容编码方式(备选编码方式) r.content HTTP响应内容的二进制形式 一般认为r.apparent_encoding比r.encoding准确 # -*- coding=UTF-8 -*- # 2017-2-28 20:04:57 import requests url = &apos;http://www.baidu.com&apos; r = requests.get(url) print r.encoding #输出encoding的格式 r.encoding = r.apparent_encoding #转换r.text的编码格式 print r.text #输出返回的页面源码 运行结果： ISO-8859-1 &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&apos;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&apos;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &apos;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&apos;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ##爬取网页的通用代码框架Requests库的异常： 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requesrs.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status:如果不是返回状态码不是200，产生异常requests.HTTPError # -*- coding=UTF-8 -*- # 2017-2-28 21:01:51 import requests def GetHTMLText(url): try: r = requests.get(url) #发送HTTP请求 r.raise_for_status #抛出异常 r.encoding = r.apparent_encoding #改变编码方式 return r.text #返回网页内容 except: return &apos;代码异常&apos; if __name__ == &apos;__main__&apos;: url = &apos;http://www.baidu.com&apos; print GetHTMLText(url) ##HTTP协议及Requests库方法Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，是支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应与HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HEML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE HTTP协议简介URL格式：http://host[:port][path]host:合法的Internet主机域名或IP地址port:端口号，缺省端口为80path:请求资源的路径 HTTP URL的理解：URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源 HTTP协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 POST 请求向URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该出资源的部分内容 DELETE 请求删除URL位置存储的资源 requests库的head()方法 # -*- coding=UTF-8 -*- # 2017-2-28 21:39:41 import requests url = &apos;http://www.baidu.com&apos; r = requests.head(url) #requests库的head()方法 print r.headers #打印获取的头部信息 运行结果 {&apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Last-Modified&apos;: &apos;Mon, 13 Jun 2016 02:50:34 GMT&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 13:38:58 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;} requests库的post()方法 # -*- coding=UTF-8 -*- # 2017-2-28 21:44:35 import requests url = &apos;http://httpbin.org/post&apos; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} r = requests.post(url, data = payload) #requests库的post()方法 print r.text #打印文件内容 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } 新增了 &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, ##Requests库主要方法解析Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，是支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应与HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HEML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE requests.request(method, url, **kwars) method:请求方式，对应get/put/post等七种 r.requests.request(‘GET’, url, **kmargs) r.requests.request(‘HEAD’, url, **kmargs) r.requests.request(‘POST’, url, **kmargs) r.requests.request(‘PUT’, url, **kmargs) r.requests.request(‘PATCH’, url, **kmargs) r.requests.request(‘delete’, url, **kmargs) r.requests.request(‘OPTIONS’, url, **kmargs) url:拟获取页面的URL链接 **kwargs:控制访问的参数，共13个 params:字典或字节序列，作为参数增加到url中 # -*- coding=UTF-8 -*- # 2017-2-28 21:56:50 import requests url = &apos;http://httpbin.org/post&apos; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} r = requests.request(&apos;GET&apos;, url, params = payload) #request方法的params参数 print r.url #打印url 运行结果 http://httpbin.org/post?key2=value2&amp;key1=value1 data:字典、字节序列或文件对象，作为Requests的内容 # -*- coding=UTF-8 -*- # 2017-2-28 22:06:00 import requests url = &apos;http://httpbin.org/post&apos; kv = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key3&apos;: &apos;value3&apos;} r = requests.request(&apos;POST&apos;, url, data = kv) #request方法的data参数 print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;value3&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;35&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } json：JSON格式的数据，作为Request的内容 # -*- coding=UTF-8 -*- # 2017-2-28 22:08:57 import requests url = &apos;http://httpbin.org/post&apos; kv = {&apos;key1&apos;: &apos;value1&apos;} r = requests.request(&apos;POST&apos;, url, json = kv) #request方法的json参数 print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;{\\&quot;key1\\&quot;: \\&quot;value1\\&quot;}&quot;, &quot;files&quot;: {}, &quot;form&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;18&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: { &quot;key1&quot;: &quot;value1&quot; }, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } header：字典，HTTP定制头 # -*- coding=UTF-8 -*- # 2017-2-28 22:13:23 import requests url = &apos;http://httpbin.org/post&apos; hd = {&apos;user-agent&apos;: &apos;Chrome/10&apos;} r = requests.request(&apos;POST&apos;, url, headers = hd) #request方法的header参数 print r.headers #输出对应资源 运行结果 {&apos;Content-Length&apos;: &apos;316&apos;, &apos;Server&apos;: &apos;nginx&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, &apos;Date&apos;: &apos;Tue, 28 Feb 2017 14:11:55 GMT&apos;, &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;} cookies:字典或CookieJar,Request中的cookie auth:元组，支持HTTP认证功能 files:字典类型，传输文件 # -*- coding=UTF-8 -*- # 2017-2-28 22:51:51 import requests url = &apos;http://httpbin.org/post&apos; fs = {&apos;files&apos;: open(&apos;stdin.txt&apos;, &apos;rb&apos;)} r = requests.request(&apos;POST&apos;, url, files = fs) #request方法的files参数 r.encoding = r.apparent_encoding print r.text #输出对应资源 运行结果 { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: { &quot;files&quot;: &quot;just some test\\r\\nanother&quot; }, &quot;form&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;169&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=76d625c06e9245209af4d8a44efd9210&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.13.0&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;27.18.150.95&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } timeout: 设定超时时间，秒为单位 r = requests.request(&apos;GET&apos;, url, timeout = 10) proxies:字典类型，设定访问代理服务器，可以增加登录认证 pxs = {&apos;http&apos;: &apos;http://user:pass@10.10.10.1:1234&apos;, &apos;https&apos;: &apos;https://10.10.10.1:4321&apos;} r = requests.request(&apos;GET&apos;, &apos;http://www.baidu.com&apos;, proxies=pxs) allow_redirects: True/False，默认为True，重定向开关 stream:True/False, 默认为True，获取内容立即下载开关 verify:True/False, 默认为True，认证SSL证书开关 cert:本地SSL证书路径 requests.get(url, params=None, **kwargs) url:拟获取页面的URL params:url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数(除了params) requests.head(url, **kwargs) url:拟获取页面的URL **kwargs：13个控制访问的参数 requests.post(url, data=None, json=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 json：JSON格式的数据，Request的内容 **kwargs：11个控制访问的参数 requests.put(url, data=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 **kwargs：12个控制访问的参数 requests.patch(url, data=None, **kwargs) url:拟获取页面的URL data:字典、字节序列或文件，Request的内容 **kwargs：12个控制访问的参数 requests.delete(url, **kwargs) url:拟获取页面的URL **kwargs：13个控制访问的参数 ##Robots协议作用：网站告知网络爬虫哪些页面可以抓取，哪些不行形式：在网站根目录下的robots.txt文件 ##Requests库的网络爬虫实战 ###实例1：京东商品页面的爬取 # -*- coding=UTF-8 -*- # 2017-3-1 10:33:03 import requests def getHTML(url): try: r = requests.get(url) #发送HTML请求 r.raise_for_status() #抛出异常 r.encoding = r.apparent_encoding #改变编码 return r.text[:1000] #返回前1000个字符 except: return &apos;程序异常&apos; if __name__ == &apos;__main__&apos;: #执行脚本 url = &apos;https://item.jd.com/2967929.html&apos; print getHTML(url) 运行结果 &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gbk&quot; /&gt; &lt;title&gt;【华为荣耀8】荣耀8 4GB+64GB 全网通4G手机 魅海蓝【行情 报价 价格 评测】-京东&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HUAWEI荣耀8,华为荣耀8,华为荣耀8报价,HUAWEI荣耀8报价&quot;/&gt; &lt;meta name=&quot;description&quot; content=&quot;【华为荣耀8】京东JD.COM提供华为荣耀8正品行货，全国价格最低，并包括HUAWEI荣耀8网购 指南，以及华为荣耀8图片、荣耀8参数、荣耀8评论、荣耀8心得、荣耀8技巧等信息，网购华为荣耀8上京东,放心又轻松&quot; /&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta http-equiv=&quot;mobile-agent&quot; content=&quot;format=xhtml; url=//item.m.jd.com/product/2967929.html&quot;&gt; &lt;meta http-equiv=&quot;mobile-agent&quot; content=&quot;format=html5; url=//item.m.jd.com/product/2967929.html&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;link rel=&quot;canonical&quot; href=&quot;//item.jd.com/2967929.html&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//misc.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img10.360buyimg.com&quot;/&gt; &lt;link rel=&quot;dns-prefetch&quot; hr ###实例2：亚马逊商品页面的爬取","excerpt":"#Python网络爬虫与信息提取这个笔记是跟着北京理工大学计算机学院「嵩天副教授」在中国大学MOOC上的课程《Python网络爬虫与信息提取》所做的学习笔记","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"使用yilia主题遇到的一些问题","date":"2017-03-29T13:56:33.000Z","path":"2017/03/29/使用yilia主题遇到的一些问题/","text":"###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式所以就去翻yilia的配置文件啦在blog根目录下执行： vim ./themes/yilia/_config.yml 打开yilia的配置文件经过一番(神TM)推断-.-觉得文章显示全文与否的关键地方应该是这里： # 文章太长，截断按钮文字 excerpt_link: more 虽然看不懂英文，但是看懂了“文章太长”这四个字，然而下面这一句没看懂…..查了一下：excerpt–摘录、引用。 确认是这个但是还是不明白是如何使用它。经过一番天真的猜测，难道是文中出现这个词就会截断，所以叫截断按钮文字？？但是万一文档中本来就要有这个词[more]那不就有二义性了吗=.=先不想那么多，有猜想就试试吧~打开markdown文档，在第一段之后加了more，然后提交更改：hexo g -d然而….并没有预期中的效果，好吧，不是原来想的这个求问度娘0.0 然而…找半天也没看到我这个问题的解决方法，屁颠屁颠跑去知乎提了这个问题，问题挂上去之后又翻了翻度娘，竟然意外翻到了，原来是要把more放在标签里。好吧….我好傻格式是：&lt;!-- more --&gt;在文中要截断的地方加上这个标签就可以在主页上实现预览的效果了，主页里显示到这个标签之前的内容，剩下的内容可以点击展开，效果如下： ###2.如何给文章添加多标签在文章的tag标签下以无序列表的形式列出，比如： --- title: 使用yilia主题遇到的一些问题 date: 2017-03-29 21:56:33 tags: - 笔记 - 技巧 --- 效果如下： ###3.如何更改主页的头像到blog根目录下执行命令： vim ./themes/yilia/_config.yml 进入yilia主题的配置文件找到这个： #你的头像url avatar: 添加avatar的值，头像的url这个可以把头像存到github上，然后把github上给出的这个图像的url填上去就可以 ###4.如何置顶文章由于我担心博客多了之后由于内容不统一会显得十分杂乱，所以就写了一篇博客作为其余博客的目录，问题是hexo更新的时候默认是按照博客的创建时间进行排序的，这就会导致作为目录的博客随着时间的推移被挤到后面去，就起不到索引的作用了，所以查了一下文章置顶的方法 title: 博客目录(索引)date: 2018-01-22 18:19:50tags: 关于此博客 top: true 只要在博客的markdowm文档首部添上top:true即可","excerpt":"###1.主页文章如何只显示部分预览，而不是整篇文章yilia主题下发布一篇文章在主页上默认是显示整篇文章的，这个时候如果有几篇文章比较长看起来很难受还不美观。所以我自然而然地想要把它改成预览模式","categories":[],"tags":[{"name":"关于此博客","slug":"关于此博客","permalink":"http://yoursite.com/tags/关于此博客/"}]},{"title":"密码学的数学基础","date":"2017-03-29T12:03:36.000Z","path":"2017/03/29/密码学的数学基础/","text":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模 欧几里得算法gcd() /*@function int gcd(int a, int b)@author ZXLiao@data 2017-3-2 10:28:22@param a integer@param b integer@return Greatest Common Divisor**/ int gcd(int a, int b){ if(b == 0){ return a; } return gcd(b, a % b);} 扩展欧几里得算法extent_gcd() /******************** @function int extend_gcd(int a, int b, int &amp;x, int &amp;y) @author ZXLiao @data 2017-3-2 17:55:32 @param a coefficient_a @param b coefficient_b @param x solution_x @param y solution_y @return gcd(a, b) x y ********************/ int extend_gcd(int a, int b, int &amp;x, int &amp;y){ /* 大前提保证： ①ax + by = gcd(a, b)一定有整数解。 ②bx + (a%b)y = gcd(b, a%b) 与①有相同解 如果b==0；那么方程就是ax=gcd(a, b) = a； 即x = 1；另取y = 0(也可以取其他值)； */ if(b == 0){ x = 1; y = 0; return a; } int gcd = expand_gcd(b, a%b, x, y); int t = x - a/b*y; // 表达式中有x，避免x改变； x = y; y = t; return gcd; //返回的是gcd(a, b); } 乘法逆元mod_inverse() /****************** @function int mod_inverse(int a, int m) @author ZXLiao @data 2017-3-2 18:59:30 @param a @param m mod @return if without the mod_inverse return -1 else return the inverse of a under modulo m ******************/ int mod_inverse(int a, int m){ if(gcd(a, m) != 1){ return -1; } int x, y; extend_gcd(a, m, x, y); return ((x % m + m) % m); } 素数筛法求素数is_Prime() /******************** @function bool is_Prime(int a) @author ZXLiao @data 2017-3-2 22:37:02 @param a integer @return if a is a Prime return true else return false ********************/ #define __MAX 10000 bool Prime[__MAX]; void get_Prime(){ memset(Prime, true, sizeof(Prime)); Prime[0] = false; for(int i = 1; i &lt;= __MAX; i++){ if(Prime[i]){ int item = 2 * i + 1; for(int j = item * item; j &lt;= __MAX; j += (2 * item)){ Prime[j &gt;&gt; 1] = false; } } } } bool is_Prime(int a){ if(a == 2) return true; if(a &amp; 1) return Prime[a &gt;&gt; 1]; else return false; } 快速幂取模quick_pow() /******************** @function int quick_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-2 22:53:17 @param a @param n @param __MOD modulo @return (a^n)%__MOD ********************/ int quick_pow(int a, int n, int __MOD){ if(n == 0) return 1; if(n &amp; 1) return a * quick_pow(a, n - 1, __MOD) % __MOD; int t = quick_pow(a, n &gt;&gt; 1, __MOD); return t * t % __MOD; } 欧拉函数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define N 1000005 #define M 78500 //预先算出1000000内的素数个数是78499 using namespace std; bool is_Prime[N]; //用于素数筛法 int Prime[M]; //存放素数 long long int oula[N]; //存放欧拉函数 int p; void Get_Prime(){ //首先筛法筛出1000000以内的素数 memset(is_Prime, 1, sizeof(is_Prime)); is_Prime[0] = is_Prime[1] = 0; for(long long int i = 2; i &lt; N; i++){ if(is_Prime[i]){ for(long long int j = i * i; j &lt; N; j += i){ is_Prime[j] = 0; } } } } void Init(){ p = 0; for(int i = 0; i &lt; N; i++){ if(is_Prime[i]){ Prime[p++] = i; oula[i] = i - 1; } } } int main () { Get_Prime(); //根据布尔数组的值，把素数存在数组内，并且对素数的欧拉函数进行赋值 Init(); /* 欧拉函数递推关系的推导： 对于oula[x]： oula[x] = x *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ① 此时，考虑oula[x/p1]的函数值 一：倘若x/p1此时还有一个素因子p1，那么： oula[x/p1] = x/p1 *（p1 - 1）/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ② 对比①②两式可以得到oula[x] = oula[x/p1] * p1 二：倘若x/p1此时没有素因子p1，那么： oula[x/p1] = x/p1 *（p2 - 1）/ p2 *（p3 - 1）/ p3*……*（pn - 1）/pn ③ 对比①③两式可以得到oula[x] = oula[x/p1] * (p1 - 1) */ oula[0] = oula[1] = 1; //递推初始化 for(int i = 2; i &lt; N; i++){ if(!oula[i]){ //对合数进行欧拉函数求解 for(int j = 0; j &lt; p; j++){ //寻找一个素因子 if(i%Prime[j] == 0){ //找到一个素因子 int k = i/Prime[j]; //记录下i%Prime[j] if(k%Prime[j] == 0){ //对i%Prime[j]再次进行判断，发现可再次整除 oula[i] = oula[k] * Prime[j]; //递推关系 } else{ //递推关系 oula[i] = oula[k] * (Prime[j] - 1); } break; } } } } return 0; } 中国剩余定理 /******************* @function int chinese_remaining_theory(struct data _data[]) @author ZXLiao @data 2017-3-6 09:36:14 @param struct data _data: Congruence equations @return x *******************/ struct data{ int b; int m; }; int chinese_remaining_theory(struct data _data[]){ bool mark = 1; for(int i = 0; i &lt; N; i++){ for(int j = i + 1; j &lt; N; j++){ if(gcd(_data[i].m, _data[j].m) != 1){ mark = 0; break; } } } if(mark == 0){ return -1; } int M = 1; int Mi[N]; int inv[N]; int X = 0; for(int i = 0; i &lt; N; i++){ M *= _data[i].m; } for(int i = 0; i &lt; N; i++){ Mi[i] = M / _data[i].m; } for(int i = 0; i &lt; N; i++){ inv[i] = mod_inverse(Mi[i], _data[i].m); } for(int i = 0; i &lt; N; i++){ X += _data[i].b * inv[i] * Mi[i]; } return X % M; } 费马定理优化快速冥取模 /******************* @function int Format_pow(int a, int n, int __MOD) @author ZXLiao @data 2017-3-6 09:48:44 @param a @param n @param __MOD modulo @return a^n % __MOD *******************/ int Format_pow(int a, int n, int __MOD){ if(gcd(a, __MOD) == 1){ return quick_pow(a, n % (__MOD - 1), __MOD); } return quick_pow(a, n, __MOD); }","excerpt":"#信息安全的数学基础##目录 信息安全的数学基础 欧几里得算法 扩展欧几里得算法 乘法逆元 素数筛法求素数 快速幂取模 欧拉函数 中国剩余定理 费马定理优化快速冥取模","categories":[],"tags":[{"name":"信息安全","slug":"信息安全","permalink":"http://yoursite.com/tags/信息安全/"}]}]